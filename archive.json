{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-05-25T02:20:06.845412+00:00",
  "repo": "davidben/merkle-tree-certs",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOJIBkVc5gi33k",
      "title": "Time math is ambiguously-specified",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/1",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Leap seconds, UTC, TAI, etc., are all the worst. While we never actually write the timestamps on the wire, it is important that everyone agree, for a given batch number, what times they refer to.\r\n\r\nThe intent was that you just do math in POSIX time, since that's what every programming language gives you. But if there's ever another leap second, it gets a little tricky. It might be that we have to literally cite POSIX here? Something like: all of these are just measured in seconds, do the math in seconds to get a POSIX timestamp, convert the current time to POSIX time, and then compare in that space?\r\nhttps://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16\r\n\r\nOtherwise you have to answer ridiculous questions like what happens at one of the POSIX timestamps that correspond to multiple times of day.\r\n\r\nNot that anything at this granularity matters _at all_ for a PKI.",
      "createdAt": "2023-03-10T23:32:00Z",
      "updatedAt": "2023-03-18T01:18:44Z",
      "closedAt": "2023-03-18T01:18:44Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Notes to self for specifying this:\r\n* C++ says that `std::chrono::system_clock` says \"time since 1970-01-01 00:00:00 UTC excluding leap seconds\"\r\n* POSIX has a DOI, so generating the citation is pretty easy.\r\n",
          "createdAt": "2023-03-15T22:15:57Z",
          "updatedAt": "2023-03-15T22:15:57Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOJIBkVc5gql1x",
      "title": "How long must long-expired batches be served",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/2",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "As currently written, neither CAs nor the transparency service are allowed to stop serving long-outdated batches. Should we relax this? Some nuisances:\r\n\r\n* Storage windows should be much larger than validity windows, to allow for RP clock skew\r\n* If the CA's storage window is smaller than the TS's storage window, it is possible that a transparency service will fail to log something if it's really, _really_ behind. That said, it would need to be behind by more than the CA's storage window and if that's, say, a year, that's probably fine.\r\n* A bigger issue is that if the TS spins up after the CA does, it can't bootstrap itself with data before the CA's storage window (unless it pulls it from another mirror)",
      "createdAt": "2023-03-13T15:55:05Z",
      "updatedAt": "2023-06-05T12:11:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> Storage windows should be much larger than validity windows, to allow for RP clock skew\r\n\r\nFor the common case, where the roots are side-loaded to the RP, the transparency service can also side-load an approximate time. The latest batch you got is an estimate of the time!\r\n\r\n> if it's really, really behind\r\n\r\nIf a transparency service is that much behind, then it can't perform its main function: allowing clients to authenticate. (Transparency service is perhaps not the best name.)\r\n\r\nIf everything functions normally, I'd say that the CAs would really only need to store batches for another day or so. On the other hand, when things go wrong, it's nice to have some time to figure things out. We shouldn't go overboard here: it's harder for the CAs to serve a year's worth of batches, than three weeks.\r\n\r\nIndeed, the size of assertions is dominated by the size of the public keys. If they're all RSA-2048, we're looking at roughly 1.5GB per day. Serving 32GB for three weeks is much easier than 560GB. If they're all Dilithium3, then we're looking at 250GB for three weeks and 4.2TB for a year. See also #6 .\r\n\r\nI want to try making running this as easy as possible, so at the moment I'd lean towards a storage window of 4 weeks.",
          "createdAt": "2023-03-18T10:05:08Z",
          "updatedAt": "2023-06-05T12:11:59Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> For the common case, where the roots are side-loaded to the RP, the transparency service can also side-load an approximate time. The latest batch you got is an estimate of the time!\r\n\r\nYup! Though I think we should still ponder clock skew because the RP's clock may get off after this update and then fail to take new updates.\r\n\r\nAlso I think a CA's recent history, even if the cert has since been expired, is still relevant in the limit for monitoring it. After all, transparency is inherently a post-facto thing. It takes time for a logged certificate to be observed by someone. Though, yeah, maybe we don't need a whole year's worth? I dunno. It's also really the TS's history that matters, provided the TS doesn't get too behind.\r\n\r\n> If a transparency service is that much behind, then it can't perform its main function: allowing clients to authenticate.\r\n\r\nWell, it has a few functions:\r\n* Allowing RPs to accept assertions\r\n* Providing a public view of all assertions the CA has made\r\n* Maintaining the invariant that RPs only accept assertions that have been mirrored\r\n\r\nBut you're right that a TS that's so far behind isn't doing anything. It's still meeting the primary invariant, but the system's effectively down at that point. :-)\r\n\r\nAnd perhaps a bigger point is that, support the TS is down for a bit and loses some entries because they were past the CA's storage window. If zero TS instances ever saw it, while it's unfortunate to lose a view of CA misbehavior, we know that no RP ever accepted it at any point in time, so it's not a *huge* deal.\r\n\r\n> (Transparency service is perhaps not the best name.)\r\n\r\nOriginally called it \"update service\" to kinda reflect what I expect to be the most common deployment pattern, but transparency service seemed a better generalization, especially in some of the other deployment models where it's a bunch of services together. But not attached to the name.\r\n\r\n> I want to try running this as easy as possible, so at the moment I'd lean towards a storage window of 4 weeks.\r\n\r\nYeah, I think you've convinced me that, at least for the CA, it's both useful and not particularly harmful to have a short storage window. Though the language around the TS and the HTTP interface overall would need to account for it. And we probably formally need to allow the TS to have holes in this \"TS went offline and got more than 4 weeks behind\" state.",
          "createdAt": "2023-03-19T02:40:57Z",
          "updatedAt": "2023-03-19T02:40:57Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOJIBkVc5g61sf",
      "title": "merkle_tree_sha256 TrustAnchors mean different things in different contexts",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/3",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "In the context of a BikeshedCertificate, (issuer, 1000) means this certificate is part of batch 1000 in the specified CA.\r\n\r\nIn the context of trust anchor negotiation (the RP's trust anchor list, the list of aliases), it refers to a whole window. That is, if window_size is 100, sending (issuer, 1000) means you are advertising (issuer, 901) through (issuer, 1000).\r\n\r\nThis works out, but it's a little weird. Maybe we should just allocate two different ProofType codepoints, with the second one referring to the whole window?",
      "createdAt": "2023-03-15T18:21:16Z",
      "updatedAt": "2023-03-31T11:54:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "I've also started informally saying \"aliases\" now but the draft says \"additional trust anchors\". Also something to fix as we refine the negotiation story.",
          "createdAt": "2023-03-30T23:02:52Z",
          "updatedAt": "2023-03-30T23:02:52Z"
        },
        {
          "author": "nharper",
          "authorAssociation": "NONE",
          "body": "It seems that the TrustAnchor struct is used in 3 distinct places (in the BikeshedCertificate, in the RP's store identifying which certs it accepts, and sent in the TrustAnchors TLS extension). This would be clearer if at least the last use case is separated out. In the BikeshedCertificate, the TrustAnchor appears to be the correct structure. In the RP's store, a list of TrustAnchors can be simplified to an issuer_id and a range of batch_numbers (though this is an implementation detail). When negotiating the use of Merkle Tree certificates, the RP needs to communicate a list of (issuer_id, batch_number range), which can be optimized as a list of (issuer_id, latest batch_number). While (issuer_id, latest batch_number) has the same format as a TrustAnchor, is is semantically different and could be improved upon in the spec by calling it something else.",
          "createdAt": "2023-03-30T23:58:33Z",
          "updatedAt": "2023-03-30T23:58:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Yeah, I think that'd make sense. I think, when I'd originally written it, I was thinking:\r\n\r\n- RPs advertising (issuer_id, 1000) means they support (issuer_id, 1000), which is a true statement\r\n- If an RP supports 1000, it also supports 900..1000. (Or you can think of it as supporting 0..1000 and then throwing out all the expired ones.)\r\n- The subscriber/CA know this fact and so, they'll accept larger batch numbers in lieu of their current one, up to window size\r\n- RPs know that subscriber/CA knows this, so they choose not to advertise the other 99 values they also support, because you're not obligated to list everything you support, only to support everything you list.\r\n\r\nBut this is pretty confusing, so it probably makes sense to explicitly treat these as aliases.",
          "createdAt": "2023-03-31T11:50:11Z",
          "updatedAt": "2023-03-31T11:51:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Really all this is an artifact of me, at the very last minute, switching from begrudgingly conceding that the subscriber has to know something about the structure of `merkle_tree_sha256` TrustAnchors (this 1000 implies 900..1000 property) to, at the least minute, realizing you can model this with the CA handling you a pile of aliases and then scribbling that in without thinking about it too hard! :-D\r\n\r\nBut it's pretty annoying that the CA has to list out hundreds of aliases, so maybe we actually should have some notion of versioned things in the generic structure anyway...",
          "createdAt": "2023-03-31T11:54:34Z",
          "updatedAt": "2023-03-31T11:54:56Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOJIBkVc5hJ4Q1",
      "title": "Clarify that unparsable signing inputs are still misissuance",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/5",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "We currently say:\r\n\r\n> If the CA's private key signs an input that can be interpreted as a LabeledWindow structure, the CA is considered to have certified every assertion contained in every value in the `tree_heads` list, with expiry determined by `batch_number`, the position of the tree head in the list, and the CA's input parameters as described in {{parameters}}.\r\n\r\nBut this leaves open what if the CA's private key signs an input that can't be parsed. Buggy parsers in the RP are bad, but they shouldn't be instant security bugs. To fix that, we should say:\r\n\r\n* If the CA's private key signs *any* input beginning with `Merkle Tree Certificate Window\\0`, it is in scope for this document. If it cannot be parsed as a LabeledWindow, or if the hashes were invalid, this is misissuance.\r\n* Signing other labels is, a priori, also misissuance, though future protocol extensions MAY define other label prefixes that do have meaning. I.e., if we want to have the CA sign other messages with the same key, we may define a different label for it, but the CA shouldn't be allowed to just randomly sign stuff that seems like fun.",
      "createdAt": "2023-03-17T22:15:47Z",
      "updatedAt": "2023-09-08T10:11:31Z",
      "closedAt": "2023-09-08T10:11:30Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "It's implied, but we should probably also spell it out explicitly: it doesn't matter if the CA ever served the signature over the HTTP interface. If it generated such a signature, it issued it and is responsible for whatever it signed.",
          "createdAt": "2023-03-20T15:51:13Z",
          "updatedAt": "2023-03-20T15:51:13Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "There is another case: if a signature is served, which itself does not verify, then we should not count it as a misissuance. The signature would not be trusted anyway (as it doesn't verify), and this gives some robustness against some bitflips. #26 ",
          "createdAt": "2023-06-05T10:41:12Z",
          "updatedAt": "2023-06-05T10:41:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Oh yeah, there's \"I cannot parse the signature\" and \"you signed a thing that does not parse but has the right context string\". I meant the latter. I'll go rename the issue to be clearer.\r\n\r\nAgreed that if the signature doesn't verify, it's not misissuance. The system has misbehaved, but I think that can be thought of as a generalized outage. Specifically, it doesn't cause a durable security problem the way having a bad signature in the world does.",
          "createdAt": "2023-06-05T17:26:00Z",
          "updatedAt": "2023-06-05T17:26:00Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOJIBkVc5hK-07",
      "title": "Should we include or only bind public keys in assertions",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/6",
      "state": "CLOSED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The size of assertions is dominated by the public key. Classical public keys are small: ~32/64 bytes for ECC, ~256/512 bytes for RSA. Post-quantum public keys are larger. 1312/1953B for Dilithium2/3, 897B for Falcon512. There are also some unbalanced (smaller sigs, but larger public keys) schemes on the horizon with even larger public keys: 5kB for Mayo_2, \u2265500kB for UOV.\r\n\r\nInstead of storing the public key in the assertion, we could store `H(public key)` [1]. The relying party would still need to send the public key. We could include it in the bikeshed certificate.\r\n\r\nThe downsides are:\r\n\r\n1. It slightly complicates the protocol.\r\n2. We send 32 bytes extra in the TLS connection.\r\n3. We can't check for weak public keys.\r\n\r\n[1] We might actually want to do `H(domain sep || public key || claim_type || claims)`",
      "createdAt": "2023-03-18T10:31:31Z",
      "updatedAt": "2023-09-07T20:30:11Z",
      "closedAt": "2023-09-07T20:30:11Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "We don't necessarily need to send 32 bytes extra in TLS. It's a little gross, but the RP could reconstruct the assertion with the hashed value. (Arguably it's better to make them do that, so they don't accidentally forgot to check H(pubkey) matches.)\r\n\r\nI kept thinking this would impede transparency somewhat, but I think that's just faulty intuition. If you know the set of expected pubkeys, you can check for an unexpected hash just as easily as an unexpected pubkey. And if you don't know the set, it's not like the unhashed pubkey is any more checkable (point 3 aside) than the hashed one.\r\n\r\nAnd yeah if serving obligations are a problem for CAs and TSs, a 30x size decrease sounds like a good way to clear it! :-) Though we'd have to be crystal clear that *any* unexpected pubkey hash counts as an unauthorized certificate, of equal severity, whether monitors can produce a preimage or not. That is, a CA can't say \"that's weird, but it's not a security issue because we promise no pubkey hashes to it\".  (Relatedly, #5.)\r\n\r\nAnother oddity: I think CAs typically check proof of possession of the private key, so they would need to see the preimage during issuance. We also expect CAs to have audit logs of everything they do. I think those together mean the CA must *store* the private key one way or another. If so, this would only offset serving costs, rather than storage costs. And if the CA's required to store it, they probably should still be able to produce it on demand, but I suppose that needn't necessarily be served online / mirrored by everyone.\r\n\r\n@devonobrien for thoughts on this.",
          "createdAt": "2023-03-20T15:28:35Z",
          "updatedAt": "2023-03-20T15:28:35Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> It's a little gross, but the RP could reconstruct the assertion with the hashed value.\r\n\r\nOh, yes, of course :facepalm:, that's the obvious thing to do.\r\n\r\n>  any unexpected pubkey hash counts as an unauthorized certificate\r\n\r\nYes, definitely. (You could see this as a transformation of the underlying signature scheme: we're changing pk into H(pk) and sig into pk || sig.)\r\n\r\n> If so, this would only offset serving costs, rather than storage costs.\r\n\r\nAside from material cost, there is also the effort of keeping it running under stress or recovering from issues: it's easier to quickly fix something in a 100GB database, than a 3TB database.",
          "createdAt": "2023-03-21T10:29:32Z",
          "updatedAt": "2023-03-21T10:29:32Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> It's a little gross, but the RP could reconstruct the assertion with the hashed value.\r\n\r\nWe should include the hash because otherwise the TS can't generate the Merkle tree.",
          "createdAt": "2023-03-31T23:38:37Z",
          "updatedAt": "2023-03-31T23:38:50Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Oh yeah the CA-to-TS format definitely needs to include the hash. And I suppose that's the main nuisance here. The ideal format from CA to TS and subscriber to RP now differ and we need to keep them all straight, or pay some costs.",
          "createdAt": "2023-04-01T01:28:38Z",
          "updatedAt": "2023-04-01T01:28:38Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "We can't leave out the hash from the assertion as served by the CA to the TS, but we could leave out the hash from the. BikeshedCertificate. That would complicate its definition a bit: we'd need two different Assertion structs.",
          "createdAt": "2023-06-05T11:49:19Z",
          "updatedAt": "2023-06-05T11:49:19Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOJIBkVc5hOLvI",
      "title": "Should TLS CertificateType incorporate SubjectType?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/7",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Right now we have one TLS CertificateType value, `bikeshed`, for all of BikeshedCertificate. This is good for treating ProofType opaquely, but it also negotiates all SubjectTypes at once.\r\n\r\nThe SubjectType for TLS is implicitly `tls`, so that works out. But suppose we needed to define something like. If we build a TLS out of a different key type (e.g. KEMTLS), it'll want a different SubjectType. Or maybe we just decide we need to define `tls2` for some reason.\r\n\r\nSomething like KEMTLS might its own negotiation story anyway, so this may be fine. Something like `tls2` would need its own signaling extension. Perhaps we should just rename it to `bikeshed_tls` which is BikeshedCertificate + SubjectType = tls. And then other SubjectTypes intended for use with TLS just get their own corresponding CertificateType values.",
      "createdAt": "2023-03-19T20:35:49Z",
      "updatedAt": "2023-06-12T13:17:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "In the current ~KEMTLS~ [AuthKEM draft](https://www.ietf.org/archive/id/draft-celi-wiggers-tls-authkem-01.html) it's negotiated by assigning `signature_algorithms` codepoints to KEMs. That would just work with MTC: no need to do something special. I'm afraid I do not see an advantage of a separate SubjectType, except for elegance.\r\n\r\n@thomwiggers What's your take?\r\n",
          "createdAt": "2023-06-08T13:28:03Z",
          "updatedAt": "2023-06-08T13:28:03Z"
        },
        {
          "author": "thomwiggers",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not exactly read into the MTC draft yet; but I can maybe help clarify why AuthKEM reuses the `signature_algorithms` codepoint: \r\n\r\n1. In our view, `signature_algorithms` covers authentication algorithms and controls switching between them; AuthKEM introduces new authentication algorithms.\r\n2. Reusing it was easier in my own implementations.\r\n3. Reusing it avoids having to decide and specify preference between an AuthKEM extension and \"legacy\" `signature_algorithms`\r\n\r\nFor these reasons, if AuthKEM is standardized, I expect this to stay the same.\r\n\r\nI'm not exactly sure what the SubjectType and CertificateType impose in terms of security or negotiation expectations?\r\n\r\n",
          "createdAt": "2023-06-12T12:52:27Z",
          "updatedAt": "2023-06-12T12:52:27Z"
        },
        {
          "author": "thomwiggers",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I read a bit further and these are my very, very rough thoughts. I may be missing the mark here, but I'm still sharing them because if wrong I still hope that the way I misread things can be instructive \ud83d\ude04  \r\n\r\nSkimming the draft, I am getting the impression that it does indeed seem that the CertifiateType and SubjectType are currently very related, and it seems unlikely that the same certificate may be used for different purposes (which I guess is already sort of the case with certificates because they specify EKUs?). The suggestion in the text to just add new certificate types to TLS if that becomes necessary (i.e., `bikeshed_tls2`) seems very reasonable. \r\n\r\nIn terms of implementing that in TLS, I would expect that this might also be easier; I imagine that a new `SubjectType` requires branching of the certificate handling anyway, so branching on `CertificateType` might be just as easy?",
          "createdAt": "2023-06-12T13:17:02Z",
          "updatedAt": "2023-06-12T13:17:02Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOJIBkVc5hTEdD",
      "title": "Should the RP advertise TrustAnchor exclusions on top of TrustAnchor sets?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/8",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/davidben/merkle-tree-certs/issues/3 discusses how the negotiation scheme really believes in sets of TrustAnchors. That is, the BikeshedCertificate is identified by a TrustAnchor, say (issuer, 950), but the RP sends a single value that means (issuer, 901..1000).\r\n\r\nSuppose some batch, (issuer, 975) went wrong. Because our sets have fixed width, we have to wait for the certificate lifetime to pass (i.e. the bad batch falls off the validity window) before RPs can accept anything from the CA again. Because even if the TS can tell the RP \"trust (issuer, 901...1000) but skip (issuer, 975)\", the RP can't tell the subscriber this. Over-advertising in the ClientHello risks the subscriber picking the bad batch.\r\n\r\nTwo answers for this:\r\n* Just advertise it anyway. The CA knows it messed up, so it's the CA's responsibility to get all the subscribers to renew and dump the old proof (e.g. with ACME ARI)\r\n* We have some way to list exclusions\r\n\r\nThe second could be interesting. What if we could send an exclusion list somehow? Either an explicit list of TrustAnchors, or some sort of hashing scheme. Structures, like CRLlite's Bloom filter cascade or perfect hashing describe a subset of a finite universe of inputs. If we can make that compact enough, that might be useful...\r\n\r\nIn particular, in a more traditional PKI mechanism, that would allow RPs to advertise supersets like \"CCADB/2023-03-20\" and then exclude the entries in there they don't trust.\r\n\r\nAlso, consider a distrust. Let's say I currently trust \"roots-v1\" which contains a bunch of CAs, {CA1, CA2, CA3, ...}, but now I need to distrust CA1. I can mint \"roots-v2\", but until the subscribers all get new alias lists from ACME, they won't understand it. The existing subscribers on CA2, CA3, etc., only know about \"roots-v1\". But if I advertise \"roots-v1\", the existing subscribers on CA1 will mistakenly believe their proof is still okay.",
      "createdAt": "2023-03-20T15:46:46Z",
      "updatedAt": "2023-06-14T12:01:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> Two answers for this\r\n\r\nLet me add a few other options:\r\n\r\n1. When the browser sees a proof from the bad batch, it retries the handshake excluding the CA or with Merkle Certs disabled.\r\n2. We completely distrust the CA that screwed up. The CA can then get a new CA id and mint new certs.\r\n\r\nYou are discussing two different exclusions: excluding CAs from a set and excluding batches from a CA. I think the former is more worthwhile than the latter. Hopefully it's rare that we need to exclude single batches. It'll be much more common that someone wants to exclude a CA completely from a set.",
          "createdAt": "2023-03-21T14:58:55Z",
          "updatedAt": "2023-03-21T14:59:04Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> You are discussing two different exclusions: excluding CAs from a set and excluding batches from a CA. I think the former is more worthwhile than the latter.\r\n\r\nAgreed. Yeah, I mention the batches one just because it's more immediately relevant, but I was mostly thinking about it in the context of this CA set idea. That, I supsect, fits a bit more into a signature-based ProofType (which the doc's not defining) than this Merkle Tree one.",
          "createdAt": "2023-03-21T22:59:21Z",
          "updatedAt": "2023-03-21T22:59:21Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Just realised: a non-canonical assertion (not sorted) is a good reason to exclude a batch, but not reject the whole CA. #31 ",
          "createdAt": "2023-06-14T12:01:43Z",
          "updatedAt": "2023-06-14T12:01:43Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOJIBkVc5hbOlT",
      "title": "Feature Request: Support for IP ranges",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/9",
      "state": "OPEN",
      "author": "bemasc",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Analogous to DNS wildcards, it would be helpful to support IP range claims like `192.0.2.0/24`.",
      "createdAt": "2023-03-21T18:54:29Z",
      "updatedAt": "2023-03-21T18:54:29Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOJIBkVc5hbvK1",
      "title": "Question: SubjectType, Intermediate CAs, and cross-signing",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/10",
      "state": "OPEN",
      "author": "bemasc",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It seems like right now, there is only one SubjectType (\"tls\").  Since Intermediate CAs (ICAs) are not signing TLS keyshares, this seems to mean that ICAs are not (yet) supported.  I don't know that ICAs are important per se, but cross-signing has been an important way for new CAs to gain trust, and has the effect of making them ICAs from the point of view of pre-existing clients.\r\n\r\nIs there a plan here to support ICAs?  If so, I think it will be important to specify name constraints from the beginning.  (Adding constraints as an extension didn't work last time...)\r\n\r\nRelated brainstorm: it would be helpful to have a clear way for one CA to manage multiple independent signature streams.  That way, I can put my ICA/cross-signs into a very low-throughput stream that generates very small inclusion proofs, separate from my high-volume end-entity stream that generates larger proofs.",
      "createdAt": "2023-03-21T20:42:55Z",
      "updatedAt": "2023-03-21T23:05:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "I don't think ICAs makes sense for specifically the Merkle Tree ProofType. The Merkle Tree ProofType already presumes an updated RP. Particularly in a world of giant PQ signatures, there's no point in doing that on the Subscriber <-> RP flow. Just push the new CA to the RP.\r\n\r\nThe document doesn't define other ProofTypes, but, for unupdated RPs, one could imagine defining a signature-based ProofType that looks more like X.509. In that case, yeah, I agree delegation makes sense. (Although large signatures shift the tradeoffs between delegations vs. RP updates a bit.)\r\n\r\nBut since X.509 path-building has been a disaster, I don't think that should be done with SubjectType and chaining. Rather, the chain of delegations and signatures should be embedded into `proof_data` directly. From the perspective of the subscriber, the whole chain is an atomic unit.\r\n\r\nAnd, yeah, definitely agreed that will require working through a whole lot of details, including constraints. I... have some thoughts on this, but have not yet put them together into anything coherent, so just started with the Merkle Tree idea. \ud83d\ude04 ",
          "createdAt": "2023-03-21T22:55:14Z",
          "updatedAt": "2023-03-21T23:05:58Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOJIBkVc5hitCu",
      "title": "Clarify you send only one CertificateEntry in TLS",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/11",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "TLS Certificate messages technically have a whole set of them, to form a chain. We expect any chaining behavior to fit inside the `proof_data` field (see discussion in https://github.com/davidben/merkle-tree-certs/issues/10), so we should add a sentence to clarify this.",
      "createdAt": "2023-03-22T20:58:00Z",
      "updatedAt": "2023-04-04T13:30:55Z",
      "closedAt": "2023-04-04T13:30:55Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOJIBkVc5hitIy",
      "title": "Flesh out HTTP interface",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/12",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Filing this to capture the TODO left in the doc",
      "createdAt": "2023-03-22T20:58:20Z",
      "updatedAt": "2023-06-05T12:00:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> [[TODO: This section hasn't been written yet. For now, this is just an informal sketch. The real text will need to define request/response formats more precisely, with MIME types, etc. ]]\r\n\r\n> [[TODO: If we have the window endpoint, do we still need to separate \"info\" and \"assertions\"?]]\r\n\r\n",
          "createdAt": "2023-06-05T12:00:07Z",
          "updatedAt": "2023-06-05T12:00:07Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOJIBkVc5hitMX",
      "title": "Flesh out ACME interface",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/13",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Filing this to capture TODO in the doc",
      "createdAt": "2023-03-22T20:58:34Z",
      "updatedAt": "2025-02-12T20:06:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "NONE",
          "body": "From an absolutely minimalist perspective, ACME can do *almost* everything necessary for MTC today:\r\n- the newOrder request contains a list of identifiers\r\n- fulfilling challenges to prove domain control remains the same\r\n- the finalize request should be updated to not contain a CSR (to avoid big x509 structures and signatures in the MTC world), but otherwise works the same\r\n- finalization would take a long time (up to `batch_duration` minutes) but ACME already supports async finalization\r\n- after finalization, the order's `certificate` URL would return a (base64-encoded?) BikeshedCertificate rather than a PEM-encoded x509 Certificate\r\n\r\nThat's just two minor changes for the most basic level of support.\r\n\r\nBut, that leaves on the floor a few key questions:\r\n- How do subscribers request an MTC? Do they make their requests to a wholly different ACME server (different base directory url, etc)? Do they include some information in the newOrder or finalize request indicating that they want an MTC?\r\n- How do subscribers get both an MTC and a backup traditional certificate to use before the new batch is issued and propagated to browsers? Do they make separate newOrder requests (and potentially fulfill separate domain control challenges) for each kind? Do they make a single newOrder request which then creates multiple Order objects to be finalized separately? Does a single Order end up with multiple different certificate download links after finalization?\r\n- Imagining the future pointed at by the current draft's extensible ProofTypes, how does an ACME server indicate to the client which certificate they should present in which circumstances?\r\n\r\nI'm personally leaning towards a world where a single newOrder request can end up resulting in issuance of multiple certificates for the same pubkey+identifiers. Perhaps where the finalized Order object contains a list of both certificate download URLs and metadata about each of those certificates.",
          "createdAt": "2023-05-26T20:21:08Z",
          "updatedAt": "2023-05-26T20:21:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "From work elsewhere, it sounds like we're now leaning towards separate orders for separate issuances, with a [profile](https://datatracker.ietf.org/doc/draft-aaron-acme-profiles/) per flavor of issuance, and some other general layer directing the client to make multiple orders. If so, that would suggest that this draft's ACME integration should just be about the one ACME order, and potentially be as minimal as defining a MIME type for BikeshedCertificate.\n\nI dunno if it's worth bothering with a way for requests to signal ahead of time they'll able to handle BikeshedCertificate (if you wait until fetching the cert, we'll waste an issuance), or just continue to leave this to \"we assume the human configuring things has made sure everything is compatible\".",
          "createdAt": "2025-02-12T20:06:52Z",
          "updatedAt": "2025-02-12T20:06:52Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOJIBkVc5hveoS",
      "title": "BikeshedCertificate is a placeholder name",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/15",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Obviously we'll need to rename this at some point...",
      "createdAt": "2023-03-24T18:10:40Z",
      "updatedAt": "2023-06-14T12:06:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Related: we need a name for the parts of the proposal that are not Merkle Tree specific.",
          "createdAt": "2023-06-14T12:06:47Z",
          "updatedAt": "2023-06-14T12:06:47Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOJIBkVc5hvfAa",
      "title": "Editorial: Perhaps define certificate format earlier?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/16",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Assertions are defined up in section 4, but the corresponding certificate format is buried in 5.4.3. It is a convenient place to put it chronologically in the story, but it's kinda weird to have a core type be buried in there. Maybe we should move parts of that up to be next to Assertions.",
      "createdAt": "2023-03-24T18:12:05Z",
      "updatedAt": "2023-03-26T02:45:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Repetition is also an option. We could write \"later we will define a BikeshedCertificate as\".",
          "createdAt": "2023-03-26T02:45:21Z",
          "updatedAt": "2023-03-26T02:45:21Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOJIBkVc5hv-aW",
      "title": "Discuss clock skews",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/17",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Probably under deployment considerations. The shortlived certificate aspect assumes your clock is right. Although we also get to play on easy: we're only considering up-to-date RPs and those RPs (presumably) got a clock update in the most recent update.\r\n\r\nThe clock could have gone wrong since though, so deployments would need to ponder this.",
      "createdAt": "2023-03-24T20:03:02Z",
      "updatedAt": "2023-06-15T14:20:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Perhaps too radical of a proposal, but what is the argument against the following: an RP will accept a certificate in the latest window it has regardless of the clock.\r\n\r\nThis will make negotiation also easier. Because what if the RP has its clock skewed to the future and thinks it has a very outdated window: say only two batches of that window are valid. If it sends that it has this window to a subscriber, and the subscriber has a certificate in one of the earlier batches, it will send that one without considering the clock skew of the RP.",
          "createdAt": "2023-06-12T12:04:25Z",
          "updatedAt": "2023-06-12T12:04:25Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "The RP may not necessarily be able to contact the update server all the time. The latest window being far in the past could be clock skew, or it could just be stale. I don't think the RP should accept the batch in that case, otherwise expiry on these certificates don't work. And if expiry doesn't work, everything that follows from expiry (scope of revocation, monitoring, etc) breaks down.",
          "createdAt": "2023-06-12T14:22:42Z",
          "updatedAt": "2023-06-12T14:22:42Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Then shouldn't the RP negotiate by saying \"I'll accept these CAs with batches between n and m\", where m-n < validity_window_size? Then the only thing clock skew can do, is making n too large.",
          "createdAt": "2023-06-12T14:37:51Z",
          "updatedAt": "2023-06-12T14:37:51Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Oh yeah, that'd be a nice way to resolve that. The current negotiation scheme can't express that, but I think the current scheme needs work anyway.\r\n\r\n(Though if the fast-issuance flow gets to comparable certificate lifetimes, we'll need an answer for clock skew anyway... which may be simply \"RPs should deal with this\".)",
          "createdAt": "2023-06-15T14:20:49Z",
          "updatedAt": "2023-06-15T14:20:49Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOJIBkVc5hzIKX",
      "title": "Resolve client certificate type negotiation issues",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/18",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "See https://www.ietf.org/archive/id/draft-davidben-tls-merkle-tree-certs-00.html#name-certificate-type-negotiatio",
      "createdAt": "2023-03-26T06:39:28Z",
      "updatedAt": "2023-09-02T16:17:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I like the second proposal best. What about putting `CertificateType certificate_type` at the end of the modified `Certificate` message?",
          "createdAt": "2023-06-14T14:06:59Z",
          "updatedAt": "2023-06-14T14:06:59Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "If we're modifying the message, putting it at the front seems easier to parse. Otherwise you have to skip past the certificates to figure out how to interpret the CertificateEntry. (That's the main drawback with the first option.)",
          "createdAt": "2023-06-15T03:07:56Z",
          "updatedAt": "2023-06-15T03:07:56Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that's best for the first proposal. I was thinking of the second proposal.",
          "createdAt": "2023-06-15T10:36:46Z",
          "updatedAt": "2023-06-15T10:36:46Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Hmm, maybe I'm confused. To make sure we're numbering the same, first = leaf CertificateEntry has a new_cert_type extension field and second = change syntax of Certificate message? I.e. first, in my mind, was to keep the Certificate message as-is and use its existing extensions scheme. Second was to change the syntax rather than smuggling something in an extension.\r\n\r\nIf we're using a modified syntax, seems to me we ought to make parsing as possible, i.e. put the type in front. The downside of the leaving the message as-is is the parsing is a little wonky: you have to dig in the extensions list before you can interpret the certificate bytes. That said, TLS stacks usually buffer the messages and reassemble them before parsing (I know of only one counter-example), so it's not a *huge* inconvenience.",
          "createdAt": "2023-09-02T13:42:44Z",
          "updatedAt": "2023-09-02T13:42:44Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "We agree on the numbering of the proposals. My suggestion to put `CertificateType certificate_type` at the end of the modified `Certificate` message (instead of the start) for the second proposal doesn't make a huge difference. Let's just ignore it.",
          "createdAt": "2023-09-02T15:48:27Z",
          "updatedAt": "2023-09-02T15:48:27Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Ohh, is the idea that putting it in the end allows the receiver to figure out which format you've got, by seeing if there's trailing data? I figured, if we change the format, we'd do it a la RFC 8879 and allocate a new type. But whether there's appetite for that when we could just make the parser a little screwier with an extension, I dunno.",
          "createdAt": "2023-09-02T16:17:09Z",
          "updatedAt": "2023-09-02T16:17:21Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOJIBkVc5h8eVK",
      "title": "Mention canonical STHs in acknowledgements or so",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/19",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "@bifurcation reminded me at IETF that this draft shares a lot of properties with the canonical STHs proposal. We should mention it in acknowledgements\u2014apologies, that was not an intentional omission! I suspect it was just so long ago that we just forgot the original inspiration that schemes of that flavor. \ud83d\ude43",
      "createdAt": "2023-03-28T05:46:27Z",
      "updatedAt": "2025-05-22T21:23:21Z",
      "closedAt": "2025-05-22T21:22:29Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "NONE",
          "body": "FWIW, I think the way the CT version of this tended to be labeled was \"STH discipline\", in the sense that STH issuance would be \"disciplined\" to a schedule, so that relying parties would know exactly which tree heads they needed to hold on to.  See, e.g.: https://groups.google.com/a/chromium.org/g/ct-policy/c/dqFtoFBy8YU/m/Xa67FWVCEgAJ",
          "createdAt": "2023-03-28T18:11:31Z",
          "updatedAt": "2023-03-28T18:11:31Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "NONE",
          "body": "BTW, my intent bringing this up in the TLS session wasn't to claim credit, just to make sure that this wasn't going to get tripped up by the same stuff that tripped up STH discipline!",
          "createdAt": "2023-03-28T18:15:33Z",
          "updatedAt": "2023-03-28T18:15:33Z"
        },
        {
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "body": "No, thanks so much for bringing it up! STH discipline should definitely be mentioned in the doc as prior art / inspiration. Using MTCs as an optimization with a separate fallback is what allows us to use the concept at the core of STH discipline and extend it without falling into the same catch 22.",
          "createdAt": "2023-03-28T19:00:52Z",
          "updatedAt": "2023-03-28T19:00:52Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Whoops, lost track of this in the midst of the... less productive drama... but I finally dug up your original email and cited it in 3e3b0a91ea72465ae9eb40881c0c7b77c6834a6f",
          "createdAt": "2025-05-22T21:23:20Z",
          "updatedAt": "2025-05-22T21:23:20Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOJIBkVc5ihZea",
      "title": "Rename window to validity window?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/21",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "\"Window\" is a really generic word. And if we do #2, we'll have multiple windows flying around. Maybe we should call it \"validity window\"? It makes it a bit clearer that we're talking about the particular thing.",
      "createdAt": "2023-04-03T23:39:29Z",
      "updatedAt": "2023-06-23T12:00:49Z",
      "closedAt": "2023-06-23T12:00:49Z",
      "comments": []
    },
    {
      "number": 22,
      "id": "I_kwDOJIBkVc5iu9nS",
      "title": "Talk about RP <-> TS communication under Privacy Considerations",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/22",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "We do leave the exact RP <-> TS protocol out of scope, so that it can slot into existing RP update protocols, but it's probably worth calling out a couple things here:\r\n\r\n- The RP doesn't contact the TS on each TLS connection, only periodically and out-of-band\r\n- There's no reason for the RP to tell the TS anything about TLS connections. The RP just says \"give me the latest thing\" and the TS passes it along\r\n\r\nSo the only information passed along is \"I exist\", same as any other periodic update protocol.",
      "createdAt": "2023-04-06T00:10:20Z",
      "updatedAt": "2023-04-06T04:59:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "It's more than I exist: it's I'm online.",
          "createdAt": "2023-04-06T04:59:54Z",
          "updatedAt": "2023-04-06T04:59:54Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOJIBkVc5iywfV",
      "title": "Evidence",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/23",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When a CA issues an assertion, it could provide evidence for it. For instance, a (list of) serialised dnssec proof(s) for a ACME dns-01 challenge or CAA record, if that was used. Most validations are http-01 for which no proof can be produced, except perhaps a signature of an independent multi-path DCV service, if that becomes a thing. Is evidence of assertions in scope? I suppose not for an initial version.",
      "createdAt": "2023-04-06T13:53:29Z",
      "updatedAt": "2025-01-23T13:45:05Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Another application is in the initial testing phase, where some MTCAs might want to back a MTCert with an X509 cert.\n\nA basic generic type is simple enough.\n\n```\nenum {\n dnssec(0),\n x509(1),\n (2^16-1)\n} EvidenceType\n\nstruct {\n    EvidenceType evidence_type;\n    opaque evidence_info<0..2^24-1>; // or 2^16-1?\n} Evidence;\n```\n\nFor `x509`,  `evidence_info` could be a CT `X509ChainEntry`.\n\n(Maybe *supplement* is better name than *evidence*, but let's not mince words just yet.)\n\nThe question is where to put it. We'd want to have it available to transparency services, but not serve it in the certificate.\n\n1. Add a `Evidence evidence<0..2^24-1>` to AbridgedAssertion and `opaque evidence_hash[hash.length]` to Assertion. We should rename `AbridgedAssertion` then, as it's not merely an abridged version of an `Assertion`.\n2. If we only intend this for initial testing, we can add an `opaque X509ChainEntry<0..2^64-1>` in a `shadow_assertions` file next to `abrdged-assertions`.\n3. A mix is a separate `evidence` file, and `evidence_hash` in (abridged)assertion.",
          "createdAt": "2025-01-23T13:45:04Z",
          "updatedAt": "2025-01-23T13:45:04Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOJIBkVc5iy14i",
      "title": "TA negotiation useful for draft-kampanakis-tls-scas / draft-jackson-tls-cert-abridge",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/24",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The trust anchor negotiation, and the to-be-written mechanism of provisioning TLS servers with opaque TA->proof blobs, we propose would be useful for [draft-kampanakis-tls-scas](https://datatracker.ietf.org/doc/draft-kampanakis-tls-scas-latest/) as well. We could allocate a `chainless-x509-cert` trust anchor type, whose identifiers would be something akin `ccadb-20230406`, with as proof a X509 certificate whose intermediates are included in ccadb at that date. The ACME client could check CCADB for the intermediates, and if they're included, the chainless trust anchor.",
      "createdAt": "2023-04-06T14:06:28Z",
      "updatedAt": "2023-06-05T12:43:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Same for [draft-jack son-tls-cert-abridge](https://github.com/dennisjackson/draft-jackson-tls-cert-abridge).",
          "createdAt": "2023-06-05T12:43:25Z",
          "updatedAt": "2023-06-05T12:43:25Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOJIBkVc5jI0i6",
      "title": "Subscriber-level delegation",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/25",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "(Filing this mostly to capture vague thoughts. Yet another angle in this vast design space.)\r\n\r\nOver in #10 (CC @bemasc), I asserted that we didn't need delegation in Merkle Tree certificates because they don't make sense when you assume an up-to-date RP anyway.\r\n\r\nTalking with folks at IETF, someone  (I forget who... was it you, @bwesterb?) brought up that a subscriber might want to do delegation. E.g. the CA checks you're authoritative `*.example.com`, but the subscriber wants to mint credentials on demand for `abcdef.example.com`.\r\n\r\nI think the way to think about that apparent contradiction is that _CA-level_ delegation doesn't make sense with up-to-date RPs, but _subscriber-level_ delegation can still make sense. That said, the tradeoffs for such delegation are harsher in a PQ world with large signatures. So I suspect this use case will be much less applicable in the future. But perhaps there are deployments where it's still worth the extra signature.\r\n\r\nSupposing that's the case and we want to support it, one answer is to go back to a generic chaining mechanism like X.509, but another answer is to separate the two, a la TLS delegated credentials. I kinda like the latter, actually. As an RP, we already think the two cases have very different requirements. Existing CA policies often distinguish cross-signs from technically-constrained CAs. If we want to capture that, one model would be basically TLS DCs, where we have a `tls_delegated_credential_signer` (or whatever) SubjectType and some place to inject the DC. Possibly amended to allow refining the name set in the DC, I dunno.",
      "createdAt": "2023-04-11T21:40:46Z",
      "updatedAt": "2023-04-12T08:47:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> I forget who... was it you, @bwesterb?\r\n\r\nIt might've been @galadran? Anyway, I do agree.",
          "createdAt": "2023-04-12T08:47:18Z",
          "updatedAt": "2023-04-12T08:47:18Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOJIBkVc5ljPhu",
      "title": "Bitflips",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/26",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should spend a few words on what to do with bit flips.",
      "createdAt": "2023-05-10T11:44:26Z",
      "updatedAt": "2023-05-10T12:30:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I do not think we should cover all this in the draft, but it's a good exercise.\r\n\r\n1. **Bitflip in assertion** at CA. Say an assertion is published for `gnogle.com` instead of `google.com`. This should be counted as a misissuance, and detecting these is one of the reasons for CT. I'd say it's out of scope to decide what should happen next: that's a policy matter of the root programs/RPs.\r\n2. **Bitflip when computing authentication path** at CA. The subscriber will get a certificate that simply doesn't validate. The ACME client can check the certificate before installing it. This will be caught early on without lasting impact.\r\n3. **Bitflip when signing a Window** at CA. This one is trickier. On the one hand, when checking the signed window, the TS see that the batch tree heads do not match. They could simply ignore that particular window. However, the situation would be similar to when a CA tries to split the world view. I guess we will need to be tough on this one too. It's not impossible to avoid for the CA: before publishing the signed window, the CA should check whether it verifies to detect any bit flip.\r\n6. **Bitflip when serving assertions** at CA. This is related to the previous. A bit flip might make the CA serve the wrong assertion. I think we can be more lenient here. If the TS fetches the assertions a second time, it'll probably get the correct values and the window signature will validate.\r\n7. **Bitflip when serving a Window** at CA. If the bit flip is in the signature, we can be lenient. It's important that the signed message is explicit: if we would not have included the tree heads in the signed window, then we couldn't be lenient here. If the bit flip is in one of the tree head, we can also be lenient: the signature will not validate and thus we know it's not part of a split world view attack.\r\n\r\nThere must be more cases I'm missing here.",
          "createdAt": "2023-05-10T12:29:49Z",
          "updatedAt": "2023-05-10T12:30:17Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOJIBkVc5nnEh-",
      "title": "Elaborate on CA public key",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/27",
      "state": "CLOSED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In `-00` we write\r\n\r\n```\r\npublic_key: The public half of a signing keypair. The corresponding private key, private_key, is known only to the CA.\r\n```\r\n\r\nThis needs elaboration. We could pick one post-quantum signature scheme, as we have picked SHA256 as hash. Say Dilithium2. It's not unconceivable that we'll want to migrate to a new signature scheme. Perhaps because Dilithium2's security is weaker than expected, but more likely because a significantly better post-quantum signature scheme has stabilised.\r\n\r\nProofType should afford enough flexibility for this.\r\n\r\nAlternatively, we can simply use a `TLSSubjectInfo`-like structure for the CA public key.\r\n\r\nA different idea, is to use a stateful hash based signature such as LMS or XMSS. There is no need to keep state: instead we can use the `n`th one-time-signature for the `n`th window. Clients can check whether the right OTS is used. Then if the CA accidentally signs and published the same window twice, then the private key is only compromised for that window, which will be ignored anyway by TSs if such a thing happens. With `n=16`, `h=20` and `w=16`, a key pair will last 119 years, signatures will be 880 bytes, verification will take 1,181 SHA2 hashes and keygen 1 billion SHA2 hashes. The upside is that this is definitely post-quantum secure. But this is all rather more complicated to implement than a plain signature, so I suppose we're better of sticking with Dilithium for now and accept we might have to change at some point. (This would complicate signing revocation lists.)\r\n",
      "createdAt": "2023-06-02T14:19:10Z",
      "updatedAt": "2024-10-18T18:32:49Z",
      "closedAt": "2024-10-18T18:32:49Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "We probably don't need to optimize the signature here too much, compared to more fast-issuance schemes. We effectively amortize everything relating to the CA's key on the CA -> TS -> RP path. Keys and signatures barely even show up on the wire, though yeah we'll certainly need to define it as part of I guess #12.\r\n\r\nThe trick with using the counter in lieu of state is fun. I suppose, yeah, this is a place where stateful hash-based sigs are less of a disaster. But given the signature is not that load-bearing, I think \"don't do anything interesting and pick something default\" is the way to go. :-)",
          "createdAt": "2023-06-02T15:03:25Z",
          "updatedAt": "2023-06-02T15:03:25Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> signatures barely even show up on the wire\r\n\r\nShouldn't they also be sent to the browser?\r\n\r\n> don't do anything interesting and pick something default\r\n\r\nYeah, let's keep it simple for now.",
          "createdAt": "2023-06-02T15:59:51Z",
          "updatedAt": "2023-06-02T15:59:51Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> Shouldn't they also be sent to the browser?\r\n\r\nYeah, at least usually. :-) But it also happens in the RP <-> TS flow which is left somewhat unspecified. I expect browsers, for instance, would reuse their update protocols. Right now the text says:\r\n\r\n> The transparency service publishes the mirrored CA state using the same interface as {{publishing}}. The protocol between the relying party and transparency service is out of scope of this document. The relying party MAY use the interface defined here, or an existing application-specific authenticated channel.\r\n>\r\n> As discussed in {{authenticity}}, relying parties MUST ensure that any windows obtained were asserted by the CA. This SHOULD be done by having the transparency service forward the CA's signature, with the relying party verifying it. However, if the transparency service already maintains a trusted, authenticated channel to the relying parties (e.g. a software or root store update channel), relying parties MAY rely on the transparency service to validate the CA windows on their behalf, only sending valid windows over this channel.\r\n\r\nEither way, yeah, we do need to define the structure with the signed window structure because the CA <-> TS flow needs to be defined. (We actually don't _need_ define the public key format because that's never transmitted anywhere. It's part of your application-local root store configuration story. But defining a format for convenience makes sense anyway.)",
          "createdAt": "2023-06-02T17:26:44Z",
          "updatedAt": "2023-06-02T17:26:44Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOJIBkVc5npZ-_",
      "title": "Should the signing payload include 64 spaces in front?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/30",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Feedback from Ilari Liusvaara on the list:\r\n\r\n> - I think LabeledWindow should add 64 spaces in front, so it\r\n>  reuses the TLS 1.3 signature format.\r\n>\r\n>  This reduces risks of cross-protocol attack if the key gets\r\n>  reused anyway (despite there being MUST NOT requirement).\r\n\r\nI'm slightly torn on this, though I don't feel very strongly either way. (Past Davids have gone both directions on this.)\r\n\r\nOn one hand, it costs very little and reduces cross-protocol attacks with TLS 1.2 if you reuse keys. Even though we explicitly told you not to reuse those keys.\r\n\r\nOn the other hand, it only reduces attacks with TLS 1.2, and this key was already explicitly not meant to be a TLS key. Where do such things end? Should every new protocol forever guard against potential reuse with TLS 1.2, even when it (like this one) was not designed to be used with TLS? Should we guard against reuse with other protocols too? Context string constructions aren't standard (hash-to-curve does a suffix instead of a prefix), so the real defense is key separation. Maybe we should _finally_ just get better at key separation.",
      "createdAt": "2023-06-02T22:39:26Z",
      "updatedAt": "2023-06-05T10:16:05Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's good practice to add some context, which we already do, so that we can use the Merkle CA's key to sign other things besides the window. This also helps against accidental cross-protocol attacks. (Unfortunately we all haven't agreed on the standard way to do this. It'd be nice if every signature scheme would have a context string as input, but that's a separate discussion.)\r\n\r\nI don't think it's worthwhile to add the 64 spaces in front, if we mandate separate keys. We wouldn't just have to deal with TLS, but every other protocol where the same key can be used as well.",
          "createdAt": "2023-06-05T10:16:05Z",
          "updatedAt": "2023-06-05T10:16:05Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOJIBkVc5npdLL",
      "title": "Canonicalize claim structures further and think about multiplicity",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/31",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Feedback from Ilari Liusvaara on the list:\r\n\r\n>  I don't see rule for how claims are sorted within each type,\r\n>  only how different types are sorted.\r\n\r\nand:\r\n\r\n> - If each claim was in its own Claim, then one could maybe even\r\n>  shorten [the length prefix] to 8 bits. Similarly, one could merge ipv4/ipv6 and\r\n>  dns/dns_wildcard.\r\n>\r\n>  This could also simplify sorting: Sort by type, lexicographic\r\n>  sort by claim contents.\r\n\r\nMoving the multiplicity up a layer avoids every ClaimType defining it itself, and reuses some length prefixes given how the TLS presentation language works, though it means a non-multiplicative Claim would need extra logic to reject duplicates. Is that a problem?\r\n\r\nOne way or another, I am a fan of canonicalizing the order more strongly, just for the sake of having only one way to encode it. Though how we canonicalize may be interesting... if DNS names are pre-sorted in hierarchical order, evaluating name constraints efficiently becomes a lot easier.",
      "createdAt": "2023-06-02T22:56:08Z",
      "updatedAt": "2023-06-28T12:34:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, let's make sure there is one canonical presentation.\r\n\r\nTwo other points.\r\n\r\nI. `-00` reads:\r\n> Each Claim structure in an Assertion's claims field MUST have a unique `claim_type`\r\n\r\n<del>That can be read as that each Assertion can have at most one claim of a given type.</del>\r\n\r\n<ins>Update:</ins> ... which is exactly the point; I didn't read carefully and misunderstood where the multiplicity happens. I like where the multiplicity happens now.\r\n\r\nII. What about non-canonical assertions? `-00` reads:\r\n\r\n> Structures violating this constraint MUST be rejected.\r\n\r\nWe should be more specific. If a CA published a non-canonical assertion, a TS should reject the whole batch. The reason is, that it's not unlikely that relying parties' implementation will not properly check for canonicity.\r\n",
          "createdAt": "2023-06-14T11:59:08Z",
          "updatedAt": "2023-06-28T12:34:50Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOJIBkVc5npi7K",
      "title": "Feedback on hash construction",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/32",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [
        "bwesterb"
      ],
      "labels": [],
      "body": "Feedback from Ilari Liusvaara on the list:\r\n\r\n> - The root hash being dependent on issuer and batch number iff there\r\n>  are multiple assertions looks very odd.\r\n>\r\n>  Empty assertion list might be special. But this also happens for\r\n>  one assertion.\r\n\r\nIt is a little odd that HashNode takes all these extra distinguishers, but HashAssertion doesn't. @bwesterb, you suggested doing something like this to align with something that SPHINCS+ was doing, right? Should we have it on both?",
      "createdAt": "2023-06-02T23:29:22Z",
      "updatedAt": "2023-06-19T22:06:11Z",
      "closedAt": "2023-06-19T22:06:11Z",
      "comments": []
    },
    {
      "number": 35,
      "id": "I_kwDOJIBkVc5nzu6G",
      "title": "Should claims include ports?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/35",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> [[TODO: For now, the claims below just transcribe the X.509 GeneralName structure. Should these be origins instead? For HTTPS, it's a pity to not capture the scheme and port. We do mandate ALPN in {{tls-certificate-type}}, so cross-protocol attacks are mitigated, but it's unfortunate that subscribers cannot properly separate their HTTPS vs FTPS keys, or their port 443 vs port 444 keys. One option here is to have HTTPS claims instead, and then other protocols can have FTPS claims, etc.]]",
      "createdAt": "2023-06-05T11:55:14Z",
      "updatedAt": "2023-06-05T11:55:24Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 36,
      "id": "I_kwDOJIBkVc5nzvXU",
      "title": "Multiple signing keys?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/36",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> [[TODO: The signing key case is interesting. A CA could actually maintain a single stream of Merkle Trees, but then sign everything with multiple keys to support rotation. The CA -> Subscriber -> RP flow does not depend on the signature, only the CA -> Transparency Service -> RP flow. The document is not currently arranged to capture this, but it probably should be. We probably need to decouple the signing half and the Merkle Tree half slightly.]]",
      "createdAt": "2023-06-05T11:56:36Z",
      "updatedAt": "2023-06-05T11:56:36Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 37,
      "id": "I_kwDOJIBkVc5nzwlR",
      "title": "Downtime lenience",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/37",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> [[TODO: If the mirror gets far behind, if the CA just stops publishing for a while, it may suddenly have to catch up on many batches. Should we allow the mirror to catch up to the latest window and skip the intervening batches? The intervening batches are guaranteed to have been expired]] ",
      "createdAt": "2023-06-05T11:58:59Z",
      "updatedAt": "2023-06-05T14:15:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "I suspect the is the same as #2, or at least can be. Unless we want to have both a storage window and allow gaps within the storage window, but that's probably a bit much.\r\n\r\nIf we say the mirrors can't have gaps, then this equivalent to saying that if you fail to update for a whole storage window, you can just start from scratch and only catch up to whatever range you're expected to maintain in the steady state. Basically as if you were starting over as a new mirror.",
          "createdAt": "2023-06-05T14:15:26Z",
          "updatedAt": "2023-06-05T14:15:26Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "I_kwDOJIBkVc5nzyT8",
      "title": "Should TLSSubjectInfo have an extension list?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/38",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-05T12:02:28Z",
      "updatedAt": "2023-06-15T11:05:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "If the extension is critical, then it is undeployable without some form of negotiation. If there is negotiation, then instead we can simply negotiate a `TLSSubjectInfo2` via `bikeshed_tls2`, cf #7.\r\n\r\nSo, which non-critical extensions could we imagine requiring in the future? ",
          "createdAt": "2023-06-14T13:14:48Z",
          "updatedAt": "2023-06-14T13:14:48Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "The one (very, very speculative) use case I keep tossing around my head is a downgrade protection scheme.\r\n\r\nImagine if some site needs to mint both `TLSSubjectInfo` and `TLSSubjectInfo2`. Let's say we designed this back in time and `TLSSubjectInfo` is like RSA key exchange or SSL 2.0 or something horrid like that. As a server, you don't want modern clients to be vulnerable to those algorithms. But the old clients aren't gone yet, so you still need to have `TLSSubjectInfo` around. Conversely, the old servers aren't all upgraded, so the new clients still need to support the old protocols.\r\n\r\nOr even within `TLSSubjectInfo`, perhaps we're in a PQ transition state where you have both an RSA TLS key and a Dilithium TLS key, and clients support both.\r\n\r\nWe'd like for the modern clients to reject the modern server's weak credential, because they should only ever be presented with the strong credential. One way to solve this is a non-critical extension (or, equivalently, a critical extension we define today) that means \"distrust this if you understand TLSSubjectInfo2\" or \"distrust this if you understand Dilithium\". The old clients would ignore this, while the new clients would recognize it and follow the instructions.\r\n\r\n(All that said, this could just be a Claim rather than a field inside TLSSubjectInfo. It's just kinda weird because the CA isn't really validating anything about this Claim. Their only responsibility is to faithfully put in what the subscriber wanted.)",
          "createdAt": "2023-06-15T03:17:47Z",
          "updatedAt": "2023-06-15T03:17:47Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> The one (very, very speculative) use case I keep tossing around my head is a downgrade protection scheme.\r\n\r\nThat's a very good idea. I think we should include that by default. #54 \r\n\r\n",
          "createdAt": "2023-06-15T11:05:58Z",
          "updatedAt": "2023-06-15T11:05:58Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDOJIBkVc5nzy8R",
      "title": "Include new post-quantum TLS signature schemes",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/39",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> [[TODO: If other schemes get defined before this document is done, add them here. After that, it's on the other schemes to do it.]]",
      "createdAt": "2023-06-05T12:03:40Z",
      "updatedAt": "2023-06-05T12:03:40Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 40,
      "id": "I_kwDOJIBkVc5nzz99",
      "title": "[duplicate] Client certificates",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/40",
      "state": "CLOSED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> This section defines the `Bikeshed` TLS certificate type, which may be negotiated with the `client_certificate_type`, `server_certificate_type` {{!RFC7250}}, or `cert_type` {{!RFC6091}} extensions. It can only be negotiated with TLS 1.3 or later. Servers MUST NOT negotiate it in TLS 1.2 or below. If the client receives a ServerHello that negotiates it in TLS 1.2 or below, it MUST abort the connection with an `illegal_parameter` alert.\r\n>\r\n> [[TODO: None of these three extensions is quite right for client certificates because the negotiation isn't symmetric. See discussion in {{cert-type-problems}}. We may need to define a third one.]]\r\n",
      "createdAt": "2023-06-05T12:05:39Z",
      "updatedAt": "2023-06-05T12:48:04Z",
      "closedAt": "2023-06-05T12:47:15Z",
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate of #18 ",
          "createdAt": "2023-06-05T12:47:15Z",
          "updatedAt": "2023-06-05T12:47:15Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "I_kwDOJIBkVc5nz1He",
      "title": "Revocation",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/41",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> [[TODO: Is it worth defining an API for Merkle Tree CAs to publish a revocation list? That would allow automatically populating CRLite and CRLSets. Maybe that's a separate document.]] ",
      "createdAt": "2023-06-05T12:08:06Z",
      "updatedAt": "2024-07-26T14:53:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "It's tempting to include revocations in the batches, by having either (Abridged)Assertions or Revocations as leafs. So we'd have, say:\r\n\r\n```\r\nenum {\r\n    assertion(0),\r\n    revocation(1),\r\n    (2^8-1)\r\n} LeafType;\r\n\r\nstruct {\r\n    LeafType leaf_type;\r\n    opaque leaf<0..2^24-1>;\r\n} Leaf;\r\n\r\nstruct {\r\n    uint32 batch_number;\r\n    uint64 index;\r\n} Revocation;\r\n```\r\n\r\nThere are downsides:\r\n\r\n- Revocation has the same delay as issuance. With `batch_duration`s of an hour this isn't too bad.\r\n- We need to address revoking a revocation. I'd say revoking a revocation is a no-op.\r\n- The revocations will take space in the Merkle Tree: proof sizes for a batch with a huge number of revocations will increase. (This could be offset by using a list of `Revocation`s as a leaf.)\r\n-  It'll complicate the presentation of MTC: we can't say \"we build a tree on top of assertions\" anymore.\r\n\r\nAn alternative would be to have parallel batches/tree/signed windows where leafs are revocations instead of assertions. That only has the revocation delay as downside.\r\n\r\nFinally, a bespoke HTTP interface could be created that would allow for quicker revocation. That'll force us to use a clock, which we don't really need so far (see #17.)\r\n\r\nOther questions are:\r\n\r\n1. Do we need to include extra information, such as revocation reason? I'd say the full list of reasons is excessive. Perhaps just a \"key compromised\" trit (yes, no, unknown), would be ok.",
          "createdAt": "2023-06-12T13:43:35Z",
          "updatedAt": "2023-06-12T13:45:20Z"
        },
        {
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm still not confident that building in CA-initiated revocation is the best or most preferable design for e.g. 10-14 day certificates. I'd rather include explicit certificate lifetime restrictions than integrate this kind of revocation (solutions like browser-made revocation lists can still be delivered out of band). At a policy level, the CABF currently appears poised to remove the need for revocation information certificates for <= 10 day X.509 certs, which aligns with the fastest reliable revocation given CRL and OCSP caching. \r\n\r\nRegarding your downsides\r\n- We absolutely should not allow undoing revocation. That's not a currently permissible behavior in the WebPKI and we shouldn't build here, IMO.\r\n- Even if every certificate in a batch were revoked, it should only increase proof size by ~one extra hash, right? We should already have a comfortable margin on proof sizes since we don't actually control issuance rates so they can vary greatly.",
          "createdAt": "2023-06-15T09:33:15Z",
          "updatedAt": "2023-06-15T09:33:15Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> Even if every certificate in a batch were revoked, it should only increase proof size by ~one extra hash, right?\r\n\r\nYes. I was thinking of the case where you want to revoke million of certificates over multiple batches.",
          "createdAt": "2023-06-15T10:35:15Z",
          "updatedAt": "2023-06-15T10:35:15Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Some more thoughts on this.\r\n\r\n1. Another downside to using the main batches for revocations: a client is only presented with a proof of inclusion \u2014 not of non-inclusion of later revocations. The transparency service would have to build something on top anyway. Together with the existing downside that it couples issuance and revocation latency, I'd say this is dead on arrival.\r\n\r\n1. That today revocation is slow, means that we don't *need* revocation in MTC to match the status quo. I wouldn't oppose adding back in better revocation later on \u2014\u00a0as David suggested a later document.\r\n\r\n1. CRLite and variants solve a strictly harder problem than we're dealing with here: the input is a hash, and there the *universe* of possible hashes is unknown to the client (but known to the service generating the CRLite filters thanks to CT.) On the other hand, here, the universe is known: we know the number of assertions in a batch. So the task is to encode a subset (of k revoked indices) of {0, ..., n}. We can reach the theoretical minimum of lg (n choose k) for a random subset within 5% using fancy coding, and ~20% using simpler methods, beating CRLite which is about ~100%. Still, if we revoke 16 million out of 725 million, we need ~15MB, which is a lot. \r\n\r\n1. We'll need to understand how much will be revoked with shorter lifetimes. I'll look into this. I also do not believe the current high rate of revocation is security critical. Could we have clients fetch the optional compressed revocation lists directly from the CAs, which incentivises them to keep them short?",
          "createdAt": "2024-07-09T18:16:53Z",
          "updatedAt": "2024-07-09T18:16:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "I suspect revocation can always be added later, yeah. Ultimately, all we need to revoke individual entries in a batch is:\r\n* A unique way to identify the thing being revoked. X.509's original story was issuer name + serial number. We can do better without adding anything: If you're trying to identify a certification, CA name, batch number, and index. If you're trying to identify an assertion, hash the assertion.\r\n* Some way for the relying party to get the revocation information. X.509's original story was a URLs stuck into every certificate. That is a horrible waste of space and online revocation fetches by relying parties have broadly not worked. If your revocation story goes through some out-of-band process (CRLSets, CRLite, etc), we don't need to define anything. If your revocation story looks more like the failed online revocation fetches of X.509, we can just say \"the URL or so is part of the trust anchor configuration\".\r\n\r\nBut yeah I agree with Devon that the revocation story should broadly be that the assertions are short-lived enough anyway. I wouldn't want to close the door on being able to push out faster revocations, but I think the above means we can safely defer this to later.",
          "createdAt": "2024-07-14T13:28:44Z",
          "updatedAt": "2024-07-14T13:30:03Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I had a quick look at revocation behaviour of Let's Encrypt users to get some sense of what we're dealing with. July 18th (2024) I downloaded Let's Encrypt's CRLs (E1, E5, R4, R10 and R11). They contain a total of 523,178 revocations. I looked up all certificates with a _notAfter_ between July 18th 00:00:00 and August 26th 14:44:59 in Certificate Transparency (that's a bit more than 39 days). I found 166 million certificates. Of those 306,321 (0.18%) appeared in the CRLs. For each of those revoked certificates I determined how many days into its lifetime it was revoked. This is the cumulative distribution function for that:\r\n\r\n<img width=\"611\" alt=\"Screenshot 2024-07-23 at 13 31 55\" src=\"https://github.com/user-attachments/assets/99f4d821-0bc0-4747-bd99-be6f40f51d77\">\r\n\r\nNote:\r\n\r\n- 40% of revocations happen within a day of issuance.\r\n- 20% of revocations happen between 58 and 64 days after issuance. It seems likely these are revocations of certificates when they are renewed.\r\n- I didn't include the remaining 216,857 revocations with a *notAfter* after August 26th yet. This will affect the graph only for x\u226451 days. (There is a small kink at 51 days.)\r\n- There is a slight bend between the two big jumps. If we assume on every other day a certificate has the same chance to be revoked, the curve we'd get is slightly curved. The curvature would be less pronounced:\r\n\r\n<img width=\"240\" alt=\"Screenshot 2024-07-23 at 14 32 12\" src=\"https://github.com/user-attachments/assets/a80c8de8-99cb-460e-b046-473279b69733\">\r\n\r\nRough preliminary conclusion: at least 60% of Let's Encrypt revocations don't seem security related. The remaining revocations are close to uniformly distributed within a certificate's lifetime.\r\n\r\n- If we were able to ignore the former, and reduce certificate lifetime to 14 days, then only 0.0085% of certificates would be revoked. That is ~32,000 certificates, and would require a download of at least 60kB, or ~5.4kB per day (when we have sequence numbers as in MTC).\r\n- If we can't ignore the renewal and first-day revocations, then moving to 14 day certificates, the fraction of these revocations will grow to 90%. We'll have about 330k revocations. That'd be a download of at least 480kB, or 44kB per day.\r\n- Note that Let's Encrypt has relatively few revocations. If we'd keep 90 day certificates and have sequence numbers (as in MTC), the full list would take about 714kB to encode. (I'll get the actual number once I've got the full list from CT.) That's about 12.6kB per day. If we remove the renewal and first-day revocations, then it's 320kB or ~5.4kB per day.\r\n\r\nSo, shorter lived certificates makes the initial download of revocations smaller. It makes the daily updates much worse, if we do not filter out the revocations on the first day and renewals. If we do, then the daily updates should be unchanged. Similar conclusions should hold for CRLite.",
          "createdAt": "2024-07-23T13:13:46Z",
          "updatedAt": "2024-07-23T13:21:45Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Pulled remaining certs from CT. The fraction of first-day revocations is even higher than with the preliminary data: more than half the Let's Encrypt revocations happen within the first day.\r\n\r\n<img width=\"626\" alt=\"Screenshot 2024-07-25 at 23 50 08\" src=\"https://github.com/user-attachments/assets/70fc9e5a-4eb4-46d8-9c57-d534b8329b7c\">\r\n",
          "createdAt": "2024-07-25T21:51:53Z",
          "updatedAt": "2024-07-25T21:51:53Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Encoding the full list of 512,652 Let's Encrypt revocations (out of 382,584,264 ) requires 1.14MB using CRLite. With Rice coding it requires 707.3kB. Using Huffman codes for the bitlength, it's 706.5kB. The information theoretic lower bound is 703.9kB.",
          "createdAt": "2024-07-26T14:53:45Z",
          "updatedAt": "2024-07-26T14:53:45Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOJIBkVc5nz1P_",
      "title": "IANA considerations",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/42",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-05T12:08:24Z",
      "updatedAt": "2023-06-05T12:08:24Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 45,
      "id": "I_kwDOJIBkVc5n_bNf",
      "title": "Is it worthwhile to reduce reliance on collision resistance from our hash?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/45",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There has always been a significant gap between (chosen prefix) collision and (second) preimage attacks on hashes. It would be neat if we do not have to assume (chosen prefix) collision resistance of our hash to prevent certain classes of attacks. I'd say it's a nice-to-have, but not a must.\r\n\r\nIncomplete list of changes:\r\n\r\n1. For each batch, the CA generates a 16 byte randomizer `R` which is used as input to `Hash`{`Assertion`,`Node`,`Empty`}. We can either put the randomizer in the proof (in the bikeshed certificate) or pass it along in the signed window.",
      "createdAt": "2023-06-06T22:04:02Z",
      "updatedAt": "2023-06-09T12:59:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "With a CA-provided randomizer, we'd still rely on second preimage resistance for transparency, right? (I.e. we couldn't halve the hash size.) Though I suppose we wouldn't rely on it for authenticity.",
          "createdAt": "2023-06-08T22:47:45Z",
          "updatedAt": "2023-06-08T22:47:45Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, you're right: even with the CA-provided randomiser, we would still rely on *collision resistance* to prevent the CA from providing two world views. Indeed, if we'd truncate hashes to 16 bytes, then with 2^64 work, a CA could find two different batches with the same root hash.\r\n\r\nI guess we couldn't get rid of that without significant modifications (see #48). Still I think it might be worthwhile to reduce reliance of collision resistance.",
          "createdAt": "2023-06-09T12:59:25Z",
          "updatedAt": "2023-06-09T12:59:25Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "I_kwDOJIBkVc5oTIRj",
      "title": "Truncated hashes",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/48",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We might be able to get away with 16 byte hashes, by complicating the design significantly. I do not think that this  is worthwhile for the first version, but I'll write the thoughts down in this issue for future reference.\r\n\r\nIf we truncate hashes to 16 bytes, then a CA (even with the CA chosen randomiser #45) can find two different batches with the same root in 2^64 work. This allows the CA to issue certificates for assertions that escape transparency.\r\n\r\nWe can prevent this, if the CA does not control the randomiser, and only learns it after having committed to the batch.\r\n\r\nThis can be done as follows. We have two CAs. The seconds mirrors the first with an offset, so batch `n` in the first is mirrored in batch `n+offset` of the second. The first uses 32 byte hashes, and the second truncates to 16 bytes. The second uses as randomiser, public randomness that's not known before say `n+grace` where `0 < grace \u2264 offset`. For this a post-quantum version of [drand](https://drand.love) could do.\r\n\r\nBefore a TS would trust the truncated mirror, it must:\r\n\r\n1. Fetch the `n`th batch from the original before `n+grace`. This is essential, because if the first CA can delay publication of the batch until `n+grace`, it can cheat in collusion with the mirror.\r\n2. Check whether assertions of the mirror matches the original.\r\n3. Compute the root of the mirror with the correct public randomness.\r\n\r\nThe mirror could be run by a TS.\r\n\r\nThis proposal will be much harder to run, as CAs wouldn't be allowed to issue batches late, and monitors need to watch closely for late issuance.",
      "createdAt": "2023-06-09T12:59:04Z",
      "updatedAt": "2023-06-14T11:36:56Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 53,
      "id": "I_kwDOJIBkVc5ouGlb",
      "title": "GREASE",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/53",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Where should we add some [GREASE](https://datatracker.ietf.org/doc/rfc8701/)?\r\n\r\n1. We should clearly GREASE `proof_type` so that TA negotiation does not ossify.\r\n2. SubjectType is not negotiated separately, so no GREASE is required, cf #7 \r\n3. RPs must ignore unknown claims in an assertion, so it seems to be a good candidate for grease. However, do we really have flexibility in claims to begin with? For instance, suppose we do not support IP ranges (#9) in the first version, but add it later on. How would the server know it can send an assertion with a range?\r\n4. If we add extensions to TLSSubjectInfo #38, we should GREASE them. \r\n",
      "createdAt": "2023-06-14T13:29:45Z",
      "updatedAt": "2023-06-14T13:29:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 54,
      "id": "I_kwDOJIBkVc5o0dEM",
      "title": "Weak TLS handshake signature downgrade protection for PQ migration",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/54",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "TLS 1.3 has broken key exchange downgrade protection: if client and server both support (but not prefer) a broken curve, then they will still safely negotiate the preferred curve. (This does assume the other primitives, notably the handshake signature, are not broken.) This is [not the case for TLS 1.2](https://ieeexplore.ieee.org/document/8406612).\r\n\r\nTLS 1.3 doesn't have such downgrade protection for its handshake signature schemes: a MitM can always downgrade to a broken handshake signature scheme that both client and server support.\r\n\r\nFor the migration to post-quantum cryptography, it's desirable to also be able to support broken handshake signature schemes (for lagging clients), while still having downgrade protection. MTC offers an opportunity to fix this (with the big caveat that the plain X.509+CT fallback still allows the downgrade attack.)\r\n\r\nIn #38 David proposes to add a non-critical extension to TLSSubjectInfo with a weak signature scheme, that signals (which?) stronger signature schemes are supported. A client which signalled to prefer those, but didn't get them served by the server (because of a MitM) can then abort. This works, because the authentication of assertions in MTC is post-quantum secure. (Well, actually only if the MTC CA signing keys is post-quantum.)\r\n\r\nI think we should include support for this out of the box.\r\n\r\nPerhaps simply adding\r\n\r\n```\r\n    SignatureScheme other<0..2^8-1>;\r\n```\r\n\r\nto TLSSubjectInfo.",
      "createdAt": "2023-06-15T11:04:19Z",
      "updatedAt": "2023-06-21T15:44:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "\"Lagging clients\" is a bit misleading: if clients are to support MTC, then they can just as well support Dilithium2 from the get go. This downgrade protection helps if Dilithium2 turns out to be broken, or to support some clients that want to risk using classical signature schemes for performance reasons.",
          "createdAt": "2023-06-15T11:12:50Z",
          "updatedAt": "2023-06-15T11:13:15Z"
        },
        {
          "author": "thomwiggers",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> (Well, actually only if the MTC CA signing keys is post-quantum.)\r\n\r\nIt seems weird that a client would be able to verify an MTC CA signing key that is post-quantum (and unbroken), but not use the same (unbroken) algorithm in the the handshake signature---don't you mean lagging **servers** that still want to participate in MTC?",
          "createdAt": "2023-06-21T14:41:00Z",
          "updatedAt": "2023-06-21T14:41:00Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> It seems weird that a client would be able to verify an MTC CA signing key that is post-quantum (and unbroken), but not use the same (unbroken) algorithm in the the handshake signature\r\n\r\nWith the current proposal, there is only one MTC CA signature per CA per hour, that only Transparency Servers check (the latter point is up for discussion). That's quite a niche application. We could use a conservative scheme with large signatures such as SPHINCS+. Or we could even use stateful hash-based signatures there, using the `n`th one-time signature for the `n`th batch #27. Also, there are probably far fewer MTC CAs and TSs, than there are TLS servers and clients. So I do not think that what would work for the MTC CA signing key, works for the rest of the Web.\r\n",
          "createdAt": "2023-06-21T15:22:18Z",
          "updatedAt": "2023-06-21T15:23:56Z"
        },
        {
          "author": "thomwiggers",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, thanks for clearing that up. How does the client authenticate the batches it receives? If I can forge arbitrary batches because the authentication algorithm is broken or I can MITM the update process, then we still do not have this downgrade protection (with extra steps); or am I missing something?",
          "createdAt": "2023-06-21T15:28:21Z",
          "updatedAt": "2023-06-21T15:28:21Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> How does the client authenticate the batches it receives?\r\n\r\nFor the case of a browser, we assume a secure update mechanism that we leave out of scope. (Browser vendor's update servers could use pinned public keys overriding MTC.)  There still is a transparency issue though: how do we detect misbehaving browser vendors #58.\r\n",
          "createdAt": "2023-06-21T15:44:05Z",
          "updatedAt": "2023-06-21T15:44:12Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "I_kwDOJIBkVc5pKOmO",
      "title": "Expand upon security requirements of hash in security consideration section",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/55",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bwesterb"
      ],
      "labels": [],
      "body": "Cover:\r\n\r\n- Hash contextualisation, cf #32 \r\n- Where collision resistance is really used #45 ",
      "createdAt": "2023-06-19T22:08:55Z",
      "updatedAt": "2023-06-19T22:08:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 58,
      "id": "I_kwDOJIBkVc5pX_ty",
      "title": "Browser vendor transparency and relation with binary transparency",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/58",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the browser use case, the RP fully trusts the browser vendor, which could send forged roots.\r\n\r\nWe could have the browser vendor send the MTC CA signatures, but a nefarious browser could patch that out, if there is no binary transparency on the browser update mechanism.\r\n\r\nThere could be a more elegant transparency design.\r\n\r\nIs this in scope, or should we group this with binary transparency?",
      "createdAt": "2023-06-21T15:43:18Z",
      "updatedAt": "2023-06-23T02:31:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "I think this is probably out of scope. That's not to say it isn't a worthwhile problem to solve, just that I can't imagine solutions for this class of problem (binary transparency, etc.) that would interact with the MTC component. They seem truly orthogonal. Or did you have something in mind?",
          "createdAt": "2023-06-23T02:31:24Z",
          "updatedAt": "2023-06-23T02:31:24Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOJIBkVc5qgPmu",
      "title": "Pinky promises",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/61",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Somewhat similar to Signed Certificate Timestamps (SCTs) in Certificate Transparency, an MTC CA could sign an assertion before it's published, promising to include it. Dissimilar to CT, we'd want to MTC CA to also commit to the index within the batch.\r\n\r\nThis doesn't require direct sequencing if we allow empty assertions within batches.  Indeed: the MTC CA could divvy out intervals of consecutive indicies within the coming batch to different signers. Those signers could assign assertions as required without hassle of synchronisation (until they run out).\r\n\r\nThese post-quantum promises would be relatively big using a general purpose post-quantum signature scheme. In the case of MTC, we could make them relatively small by using stateful hash-based signatures where the index of the final tree matches the index of the promised point of inclusion within the batch. Using a stateful hash-based signature with two levels of subtrees: one for the batches and one for the promises within the batch, we're looking at about a 1.3kB signature with n=16, w=256.\r\n\r\nThe hard problem is how to ensure these pinky promises are kept.",
      "createdAt": "2023-07-03T21:35:33Z",
      "updatedAt": "2023-07-03T21:35:33Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 65,
      "id": "I_kwDOJIBkVc5wcNIs",
      "title": "What if lifetime not a multiple of batch_duration ",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/65",
      "state": "CLOSED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think we're not quite correct dealing with `lifetime`s that are not a multiple of `batch_duration`. Perhaps better to demand `lifetime`s to always be a multiple of `batch_duration`.",
      "createdAt": "2023-09-07T19:15:18Z",
      "updatedAt": "2023-09-08T10:14:39Z",
      "closedAt": "2023-09-08T10:14:38Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Requiring it SGTM, but out of curiousity, which part isn't quite correct?",
          "createdAt": "2023-09-07T19:34:04Z",
          "updatedAt": "2023-09-07T19:34:04Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> Requiring it SGTM, but out of curiousity, which part isn't quite correct?\r\n\r\n1. `floor(lifetime / batch_duration) + 1` is off by one if `lifetime` is a multiple of `batch_duration`\r\n2. We accept certificates outside of their lifetime (as we accept whole batches at once).",
          "createdAt": "2023-09-07T19:43:22Z",
          "updatedAt": "2023-09-07T19:43:22Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> floor(lifetime / batch_duration) + 1 is off by one if lifetime is a multiple of batch_duration\r\n\r\nAh yeah, you're right. I think I was thinking that, suppose batch_duration = 1 and lifetime = 2, at time 2.5, we actually overlap with three batch intervals, not 2. But where I got that wrong was that we only care about overlapping with the batch endpoints, not the intervals.\r\n\r\nI think the correct formulation was ceil(lifetime / batch_duration).\r\n\r\nFWIW, while I think it's reasonable to express things in terms of integers where we can, it should be a low priority consideration. We should expect implementors to know how translate an expression with ceil/floor into integer math and need not sacrifice other considerations for it. In particular...\r\n\r\n> We accept certificates outside of their lifetime (as we accept whole batches at once).\r\n\r\nI don't think that's true. We accept whole batches at once (which is fine; they have the same lifetime), but not whole windows. See step 4 here:\r\nhttps://davidben.github.io/merkle-tree-certs/draft-davidben-tls-merkle-tree-certs.html#name-certificate-verification\r\n\r\nThis was intentional. Just because a batch number is within your window _does not mean it is valid_. This is important whether or not the lifetimes are multiples of the batch duration. A relying party may be arbitrarily behind. By wall clock, maybe we are now at batch 100, but I last talked to the TS at batch 80. The far end of my window will contain only expired things, but I cannot start advertising 100 because I don't know what 100 is.\r\n\r\nThis is also why the certificate selection algorithm considers expiry, because the RP may say batch numbers that are expired. The certificate negotiation problem becomes a lot harder when RP-advertised windows aren't fixed-width.\r\n\r\n(To that end, it's also okay if we overcount our window size. It's just wasteful. \ud83d\ude04)",
          "createdAt": "2023-09-08T03:53:12Z",
          "updatedAt": "2023-09-08T03:54:53Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, you're right. Anyway, with lifetime a multiple of batch_duration, we don't have to ponder these issues anymore :).",
          "createdAt": "2023-09-08T10:14:38Z",
          "updatedAt": "2023-09-08T10:14:38Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "I_kwDOJIBkVc5wcN27",
      "title": "Avoid floating points",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/66",
      "state": "CLOSED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's tempting to compute `ceil(log_2(n))+1` using floating points. Even though I doubt we'll see batches of around 2^53 certs, it's better to stick to integers. ",
      "createdAt": "2023-09-07T19:18:01Z",
      "updatedAt": "2023-09-08T10:10:33Z",
      "closedAt": "2023-09-08T10:10:33Z",
      "comments": []
    },
    {
      "number": 69,
      "id": "I_kwDOJIBkVc5wc3QR",
      "title": "Discuss the implications of hashes with unknown preimages",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/69",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [
        "davidben"
      ],
      "labels": [],
      "body": "There are a lot of places a signature may cover a hash but the preimage is unknown. We can't distinguish unknown preimage (e.g. CA signed some garbage) from a hash whose preimage contains something nefarious, so I think we need to discuss this a bit, and whether this breaks transparency.\r\n\r\nThe story for most of these is:\r\n* This indicates misbehavior by the CA\r\n* But we broadly don't care because the TS won't forward if it can't reconstruct the tree\r\n\r\nBut we should write it down. #49 is interesting, however. Starting with #49, it is possible for a CA to sign over an abridged assertion with hash with unknown preimage. We need to be very clear that it doesn't matter whether anyone can produce the preimage. If the CA signs over that abridged assertion, they have attested to it. This is an interesting subtlety: the CA attests to abridged assertions and not every abridged assertion necessarily corresponded to an assertion.\r\n\r\nI'll see about putting together some text.",
      "createdAt": "2023-09-07T22:05:03Z",
      "updatedAt": "2023-09-08T10:14:54Z",
      "closedAt": "2023-09-08T10:14:54Z",
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2023-09-08T10:14:54Z",
          "updatedAt": "2023-09-08T10:14:54Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "I_kwDOJIBkVc5wfsGM",
      "title": "No need to be clever with the pad",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/72",
      "state": "CLOSED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the current draft we carefully add some padding in the hash, so that we can reuse the computation of the first block among many hashes. From @mia1024's PoC in Python it's clear that hashing is far from the bottleneck, but that the pad is annoying to deal with. Let's remove the pad.",
      "createdAt": "2023-09-08T10:04:40Z",
      "updatedAt": "2023-10-13T10:34:11Z",
      "closedAt": "2023-10-13T10:34:11Z",
      "comments": []
    },
    {
      "number": 75,
      "id": "I_kwDOJIBkVc5ziL2a",
      "title": "Double length prefix in Claim",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/75",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wontfix"
      ],
      "body": "A Claim is defined as\r\n\r\n```\r\nstruct {\r\n    ClaimType claim_type;\r\n    opaque claim_info<0..2^16-1>;\r\n} Claim;\r\n```\r\n\r\nFor claim_type=`dns`, the `claim_info` is to be interpreted as a `DNSNameList`, which is defined as\r\n\r\n```\r\nopaque DNSName<1..255>;\r\n\r\nstruct {\r\n    DNSName dns_names<1..2^16-1>;\r\n} DNSNameList;\r\n```\r\n\r\nThus a DNS claim for `example.com` is:\r\n\r\n```\r\n0000 000f 000d 000b 6578616d706c652e636f6d\r\n```\r\n\r\nThe first uint16 is the type. The second is the length prefix for `claim_info`. The third is the length prefix for `dns_names`.\r\n\r\nWhen writing a parser it's clear that there is a superfluous prefix in the specification. It's not that easy to express leaving it out without adding new notation to the TLS presentation language. Perhaps it's fine to leave it like this.\r\n",
      "createdAt": "2023-10-11T17:37:02Z",
      "updatedAt": "2023-10-13T10:33:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Yeah, the TLS presentation language tends to result in double prefixes like this. Not thrilled with it, but at least on the TLS side, folks seem to mostly just live with it.",
          "createdAt": "2023-10-11T17:51:39Z",
          "updatedAt": "2023-10-11T17:51:39Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDOJIBkVc5zo8QX",
      "title": "AbridgedAssertion does not contain SignatureScheme",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/76",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Is this an issue?\r\n\r\nWe could instead define AbridgedAssertion as\r\n\r\n```\r\nstruct {\r\n    SubjectType subject_type;\r\n    opaque abridged_subject_info<0..2^16-1>;\r\n    Claim claims<0..2^16-1>;\r\n} AbridgedAssertion;\r\n\r\nstruct {\r\n    SignatureScheme signature;\r\n    opaque public_key_hash[hash.length];\r\n} AbridgedTLSSubjectInfo\r\n```\r\n\r\nwhere obviously `abridged_subject_info` has to be `AbridgedTLSSubjectInfo` in case of subject_type=`tls`.",
      "createdAt": "2023-10-12T14:22:21Z",
      "updatedAt": "2023-10-12T14:28:28Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "I guess the tradeoff is we avoid redacting things we don't need, but now the verification process needs to know about TLS.\r\n\r\nI don't think redacting it is a *problem* per se, though I also don't know how much weight to put on this separation. My intuition is the separation is useful but dunno how it'll shake out.",
          "createdAt": "2023-10-12T14:28:28Z",
          "updatedAt": "2023-10-12T14:28:28Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "I_kwDOJIBkVc5z__0d",
      "title": "Hash is constrained by TrustAnchor and ProofType",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/79",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Recall\r\n\r\n```\r\nstruct {\r\n    opaque issuer_id<1..32>;\r\n    uint32 batch_number;\r\n} MerkleTreeTrustAnchor;\r\n\r\nstruct {\r\n    TrustAnchor trust_anchor;\r\n    opaque proof_data<0..2^16-1>;\r\n} Proof;\r\n```\r\nOne of the Merkle tree CA parameters is `hash`, which is implied by the TrustAnchor. But the hash is also implied by the ProofType:\r\n\r\n```\r\nenum { merkle_tree_sha256(0), (2^16-1) } ProofType;\r\n\r\nstruct {\r\n    ProofType proof_type;\r\n    opaque trust_anchor_data<0..2^8-1>;\r\n} TrustAnchor;\r\n```\r\n\r\n(As an aside: `TrustAnchorType` would be a reasonable alternate name for `ProofType`.)\r\n\r\nI do not see the advantage of fixing the hash with the ProofType. We do write:\r\n\r\n```\r\nopaque HashValueSHA256[32];\r\n\r\nstruct {\r\n    uint64 index;\r\n    HashValueSHA256 path<0..2^16-1>;\r\n} MerkleTreeProofSHA256;\r\n```\r\n\r\nBut we could have just as well have written\r\n\r\n```\r\nopaque HashValue[hash.len];\r\n\r\nstruct {\r\n    uint64 index;\r\n    HashValue path<0..2^16-1>;\r\n} MerkleTreeProof;\r\n```\r\n\r\nNote that we do not need to include the hash in the ProofType for negotiation. Indeed: the RP trusts certain anchors whose hashes are fixed \u2014 there is no situation where the subscriber would send a proof from a trusted anchor whose hash is not supported.",
      "createdAt": "2023-10-16T21:47:08Z",
      "updatedAt": "2024-07-26T06:46:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Arguably we don't need to fix anything in the ProofType. If you know the ID of the trust anchor, you know its properties. If you don't, you don't care. But, if we have a ProofType enum at all, I think capturing the hash is useful for a few reasons:\r\n* If someone writes tooling like Wireshark to lightly parse these, they have enough information to do so.\r\n* We'll probably eventually need to serialize a CA's information in some way. _Then_ we'll need to capture the hash function. May as well incorporate it into the type enum and avoid inventing yet another enum\r\n* It's not just the hash function but also if we need to tweak the construction in any way, that can be rolled into it. (E.g. `merkle_tree_sha256_v2`)\r\n* Discouraging needless proliferation of variants is a _good_ thing. The last thing we want is for a not-fit-for-purpose hash function like SHA-3 to get in here. I mean, we probably could have just called it `merkle_tree` and said that codepoint always means SHA-256. If you want a different hash, it's the same as if you need to change any other aspect of the construction: pick a new codepoint.",
          "createdAt": "2023-10-24T05:03:11Z",
          "updatedAt": "2023-10-24T05:03:35Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> * If someone writes tooling like Wireshark to lightly parse these, they have enough information to do so.\r\n\r\nThey already have: we use a length-prefix for the path. For ValidityWindow we do not, but there is no ProofType value anyway.\r\n\r\n> * We'll probably eventually need to serialize a CA's information in some way. _Then_ we'll need to capture the hash function. May as well incorporate it into the type enum and avoid inventing yet another enum\r\n> * It's not just the hash function but also if we need to tweak the construction in any way, that can be rolled into it. (E.g. `merkle_tree_sha256_v2`)\r\n> * Discouraging needless proliferation of variants is a _good_ thing. The last thing we want is for a not-fit-for-purpose hash function like SHA-3 to get in here. I mean, we probably could have just called it `merkle_tree` and said that codepoint always means SHA-256. If you want a different hash, it's the same as if you need to change any other aspect of the construction: pick a new codepoint.\r\n\r\nExcept for your characterisation of SHA3, I completely agree. But then why not remove the \"sha256\" from the struct names, and say it's SHA-256 for \"merkle_tree_v1\". If we need to switch to anything else (and I doubt that'll happen), we can use \"merkle_tree_v2\".\r\n\r\n",
          "createdAt": "2023-10-24T10:59:43Z",
          "updatedAt": "2023-10-24T10:59:43Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "No particular opinions on whether there's a \"sha256\" in the name. It's just naming at that point. I guess it's an implicit answer to people asking \"what if we I want to change the hash\", while still making it structurally a \"codepoint captures all the parameters\" kind of deal.",
          "createdAt": "2023-10-24T13:40:59Z",
          "updatedAt": "2023-10-24T13:40:59Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "I'm starting to suspect ProofType will be gone after I've finished up #80, but we'll see. We can still have it if we really want, but with TrustAnchors replaced with undecorated OIDs, there won't be a natural excuse to wire it in.",
          "createdAt": "2024-07-26T06:45:59Z",
          "updatedAt": "2024-07-26T06:45:59Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "I_kwDOJIBkVc52Stvx",
      "title": "Rebase negotiation scheme on top of trust anchor IDs",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/80",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [
        "davidben"
      ],
      "labels": [],
      "body": "We can probably also trim the now redundant text around multi-certificate deployment models.",
      "createdAt": "2023-11-09T00:36:17Z",
      "updatedAt": "2024-08-11T23:44:41Z",
      "closedAt": "2024-08-11T23:44:41Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Based on TLSWG feedback, we're going to proceed with draft-beck-tls-trust-anchor-ids over draft-davidben-tls-trust-expr, so now this tracks rebasing over the other one. I believe the things to do are:\r\n\r\n1. Replace `issuer_id` with the same OID-based construction used by trust anchor IDs. However, that does not name an individual trust anchor but takes the entire OID arc\r\n2. A trust anchor is just an individual batch, which is constructed by appending the batch number to the OID\r\n3. Replace the `TrustAnchor` structure in `BikeshedCertificate` with a `TrustAnchorIdentifier` from draft-beck. Unlike X.509, there is need to communicate the trust anchor ID in `CertificatePropertyList`. The subscriber is assumed to understand the `BikeshedCertificate` structure and can parse it out. (X.509 only needs it because its native issuer field is horrible.)\r\n4. Delete the `trust_anchors` extension in this document and just reference draft-beck. Much of the supporting musing on deployment can also probably go.",
          "createdAt": "2024-07-26T05:39:55Z",
          "updatedAt": "2024-07-26T05:39:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "The ACME bits may also need thought, but I think we leave that for later and just drop in a TODO. draft-beck has an ACME extension, but MTC's long issuance times complicate matters.",
          "createdAt": "2024-07-26T05:41:35Z",
          "updatedAt": "2024-07-26T05:41:35Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I presume we'd only want the client to send the trust anchor of the latest batch it has \u2014\u00a0and not all batches it trusts?",
          "createdAt": "2024-07-26T10:15:33Z",
          "updatedAt": "2024-07-26T10:15:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Hmm. I think we'd effectively have to depend on the DNS advertisement because otherwise it's too large. I guess, yeah, we will lose the goofy thing we did here where one trust anchor ID secretly aliases a bunch of others concurrently. I'm thinking we tentatively just lose it and take a DNS dependency, and then we can always add it back later.\r\n\r\nI'll leave a little TODO for it.",
          "createdAt": "2024-07-26T16:36:57Z",
          "updatedAt": "2024-07-26T16:36:57Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> I'll leave a little TODO for it.\r\n\r\nAlso will file a bug in the other repo to track this.",
          "createdAt": "2024-07-26T16:40:55Z",
          "updatedAt": "2024-07-26T16:40:55Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "I_kwDOJIBkVc53nXHx",
      "title": "Batch number for \"negative\" batches",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/81",
      "state": "CLOSED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When issuing the first few batches, we need stand-in roots for the \"negative\" batches. The current text does not specify which `batch_number` should be used. I think it's fine to simply use 0 for all those.",
      "createdAt": "2023-11-22T17:29:56Z",
      "updatedAt": "2023-11-22T17:49:56Z",
      "closedAt": "2023-11-22T17:49:56Z",
      "comments": []
    },
    {
      "number": 83,
      "id": "I_kwDOJIBkVc57_4GN",
      "title": "Subscriber-imposed certificate expiry",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/83",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [
        "davidben"
      ],
      "labels": [],
      "body": "Certificates currently all expire as the batch expires, which come from a technical requirement of the mechanism. However, when requesting a certificate, the subscriber may have even tighter opinions on expiry, based on its own key management goals. Probably not likely with MTC certificate lifetimes, but we do mean for BikeshedCertificate to be extensible and ACME does allow the subscriber to request a notAfter date.\r\n\r\nIf the subscriber requests a tighter notAfter date than the corresponding batch, the ACME server would need to choose between not issuing a Merkle tree certificate, or extending the subscriber's vulnerability to it key longer than requested. We could avoid that by adding an extra expiration time inside the certificate. The semantics would be that you check *both* that expiration time and the batch-level one. (Equivalently, require they be consistent. But checking both may be more straightforward since we need the RP to check anyway.)\r\n\r\nNot sure whether this should go in Assertion + AbridgedAssertion, or MerkleTreeProofSHA256 + HashAssertionInput. I'm envisioning the Assertion being something that the subscriber puts together, that plugs into CSRs and any other proof-of-possession checks. Saying that the subscriber's Assertion is byte-for-byte identical to the one in the certificate gives a lot of nice properties, but in other proof types, a CA may wish to express a tighter lifetime than what the subscriber requested. That would suggest the CA-imposed expiry, in general, needs to be outside the assertion. (CA-imposed expiry is implicit in MTCs, but may not be in other constructions.) But then we might want PoPs to express a subscriber-imposed expiry, which would mean this \"check both CA- and subscriber-imposed expiry separately\" model needs to become universal.\r\n\r\nPut another way, it's the difference between:\r\n* The statement \"the key 1234 is good for example.com\" is true until 2024-01-31\r\n* The statement \"the key 1234 is good for example.com until 2024-01-20\" is true until 2024-01-31\r\n",
      "createdAt": "2024-01-13T15:22:29Z",
      "updatedAt": "2025-03-13T02:43:04Z",
      "closedAt": "2025-03-13T02:43:04Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Hmm, I may be overthinking this. Proof-of-possession schemes can still have expiry by just putting it outside the assertion. Having assertions themselves be timeless makes it a lot easier to say things like \"I'm looking for sha256(assertion)\", without having the identity of the assertion change over time.\r\n\r\nLeaning towards doing it outside the assertion.",
          "createdAt": "2024-01-13T15:25:39Z",
          "updatedAt": "2024-01-13T15:25:39Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Makes sense. We should keep this in mind when designing revocation (#41): if we want revocation that's not aligned with the issue time of batches, then we could perhaps do this by issuing and immediately revoking at the intended expiry.",
          "createdAt": "2024-01-15T13:48:31Z",
          "updatedAt": "2024-01-15T13:48:31Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "I think those are separate. Any kind of revocation scheme like that will necessarily be fuzzy (e.g. only work with RPs that have gotten a fresh push) because of all the usual reasons X.509-style revocation does not work.\r\n\r\nThis is about whether there should be a way to note, in the certificate, that the subscriber, at issuance time, did not want the key to last beyond Thursday.",
          "createdAt": "2024-01-15T15:37:42Z",
          "updatedAt": "2024-01-15T15:37:42Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Also really the only thing to design in \"revocation\" is some way to uniquely identify the certificate... which I suppose does have some connection to the question of where the expiration time goes, hmm...",
          "createdAt": "2024-01-15T15:39:32Z",
          "updatedAt": "2024-01-15T15:39:32Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Will do this as part of rebasing on trust anchor IDs. This avoids needing to define a CertificatePropertyList to pass in the expiration time out-of-band.\r\n\r\nTo avoid the expiration time and proof-induced time constraint getting out of sync, the expectation will be that all proof verification algorithms will reject any certificate whose expiration time is inconsistent with the proof. That is, for MTCs, the explicit expiration time must be at or before the batch expiration.\r\n\r\n(The analogy in X.509 land would be saying that if cert1 is the issuer of cert2, we must have `cert1.notBefore <= cert2.notBefore <= cert2.notAfter <= cert1.notAfter`. Issuing a certificate that lasts longer than you is not an implicit clamping but an error.)",
          "createdAt": "2024-07-26T08:11:43Z",
          "updatedAt": "2024-07-26T08:11:43Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDOJIBkVc5_eXYW",
      "title": "Make the hashes in a batch depend on the previous batch, to make split worldviews persist",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/84",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If an MTC CA and TS conspire, the CA could have a different list of assertions for the same batch, which the TS can pass to a specific client. Assuming the client checks the validity window signature and consistency of previously seen roots, the CA will  also have to sign a dozen of extra validity windows for the lifetime of that batch, and the TS has to make sure the client gets those too.\r\n\r\nThere is a chance this deception gets uncovered: if the client checks the authentication path of an assertion in the honest batch, they'll get the wrong root.\r\n\r\nIt would be better if this deception would break all future honest assertions from the CA. This can be done as follows.\r\n\r\nFor each batch, the CA publishes (in say the validity window) a random 32 byte **randomiser**.\r\nFor each batch, we define the **key** as H( randomiser || root-of-previous-batch ).\r\nIn computing the Merkle tree, we include the key of the batch in every hash.\r\nIn the Merkle Tree proof, we include the key of the batch.\r\n\r\n(The randomiser isn't required for the issue at hand, but is motivated by #57 to reduce the security assumptions on the hash.)\r\n\r\nCame up in conversation with @dennisjackson.\r\n",
      "createdAt": "2024-02-16T13:49:34Z",
      "updatedAt": "2024-02-17T19:19:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "I thought, in other discussions, you thought it was a _good_ thing that the system was a bit less fragile when it came to bit flips because only that one batch gets burned? \ud83d\ude1b\r\n\r\nSo far the trust model has been that the TS is trusted to ensure clients only accept logged batches. I think the CA and TS conspiring is most out of scope for transparency because the TS is, be construction, the service or collection of services that ensure transparency. In the same way that, in CT, we assume the log ecosystem does not conspire with the CA. Given the TS is expected to be the software vendor's _update service_, that seems broadly fine here.\r\n\r\nOf course, it's worth reasoning through how to reduce trust, but my initial thought is this isn't worth the cost. Or at least that we need to work through some other parts of the system first.\r\n\r\nIf I'm understanding the proposal correctly, the proposal is just to chain all the trees together. And then, to validate this, we rely on per-client state to validate that all their updates chain together?\r\n\r\nBut that means that clients, and indeed every log mirror, cannot safely skip a batch, or they turn off this check. If you're offline for a while and then wake up, you won't be satisfied with a static push. You need to go back and catch up on a potentially very very long list of hashes. Or we define conditions under which the client is allowed to break this continuity, which will never be tested very well and then undo the protections anyway (the TS can just \"fail\" to serve batches for a bit until client gives up). This is related to why defining a storage window is very difficult.\r\n\r\nNow, we _could_ optimize this by using a tree structure, rather than a linear structure. Then consistency proofs are smaller and this is starting to look a lot more like vanilla CT, with all the operational challenges that entailed. The update process is still complex, but at least allows an arbitrarily out-of-date client to catch up.\r\n\r\nWhether _that's_ worth it, I'm not sure. I think it hinges on what security properties can we manage in the fast-issuance path. Fast issuance is a lot more challenging, because a lot of solutions run into a privacy issue. It's the MTC issuance that allows us to avoid that.",
          "createdAt": "2024-02-17T18:39:32Z",
          "updatedAt": "2024-02-17T18:39:32Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> I thought, in other discussions, you thought it was a _good_ thing that the system was a bit less fragile when it came to bit flips because only that one batch gets burned? \ud83d\ude1b\r\n\r\nGood portion of the bit flips can't be ignored anyway. The [PoC](https://github.com/bwesterb/mtc) computed each new batch twice and only proceeds if they match, so I'm not too worried about bit flips.\r\n \r\n>  Given the TS is expected to be the software vendor's _update service_, that seems broadly fine here.\r\n\r\nYes, I agree it's not that much of a big deal.\r\n\r\n> If I'm understanding the proposal correctly, the proposal is just to chain all the trees together. And then, to validate this, we rely on per-client state to validate that all their updates chain together?\r\n\r\nWhat I imagined is that the TS just passes the signed validity window to the client, and the client only checks that. I incorrectly thought that would be enough to break all future authentication paths for a split world view: the client will only notice if it gets an honest authentication path from the corrupted batch or the one afterwards. Oops! Off the cuff: we can get the intended behaviour by not hashing in just the previous root, but `H( previous root || H( second-to-previous root || H (third-to-previous root || ...)...)` and including  `H( first root not in window || H(second root not in window || ... ` in the signed validity window. \r\n\r\n> But that means that clients, and indeed every log mirror, cannot safely skip a batch, or they turn off this check.\r\n\r\nIf the client skips a batch, then the job of the attacker is only marginally easier: still they have to prevent the client from seeing any honest valid authentication path in the window the client did see. So I don't think it's required for clients to keep track of every batch.\r\n\r\n> If you're offline for a while and then wake up, you won't be satisfied with a static push.\r\n\r\nRequiring clients to trace back the whole history, is of course, not practical, and I don't think we need to.\r\n\r\n \r\n> Whether _that's_ worth it, I'm not sure.\r\n\r\nDefinitely not.\r\n\r\n",
          "createdAt": "2024-02-17T19:19:42Z",
          "updatedAt": "2024-02-17T19:19:42Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOJIBkVc6MNxI7",
      "title": "Use PENs to name CAs",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/85",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Once https://github.com/davidben/tls-trust-expressions/pull/30 lands, just cite the construction from there.",
      "createdAt": "2024-06-14T03:36:40Z",
      "updatedAt": "2024-09-19T21:25:15Z",
      "closedAt": "2024-09-19T21:25:15Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "This was done at some point.",
          "createdAt": "2024-09-19T21:25:15Z",
          "updatedAt": "2024-09-19T21:25:15Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "I_kwDOJIBkVc6Q7XWG",
      "title": "Define tls-server-end-point channel binding",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/86",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The tls-server-end-point channel binding is ridiculous. You actually have to break apart the X.509 signature algorithm to compute it:\r\nhttps://www.rfc-editor.org/rfc/rfc5929.html#section-4.1\r\n\r\nThere's an obvious hash from the choice of hash in MTCs, but we don't want the subscriber to have to break apart the ProofType. Thus I suggest that the hash for BikeshedCertificate is SHA-256. SHA-256 is _fine_. If we really want to cycle that hash, define a new channel binding. I started sketching out a CertificatePropertyList design, but doing that is a waste of time.\r\n\r\nThere's also a domain separation problem. The hash should have included the certificate type... we could patch this if we want, relying on X.509 certificates always starting with 0x30.",
      "createdAt": "2024-07-26T05:56:51Z",
      "updatedAt": "2024-07-26T05:57:00Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 88,
      "id": "I_kwDOJIBkVc6SPX42",
      "title": "Multi-proof certificates",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/88",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "(Not a fully-baked idea, just exploring the design space a bit.)\r\n\r\nShould we support something like multi-proof certificates? The idea would be that the certificate looks something like:\r\n\r\n```\r\nstruct {\r\n    TrustAnchorIdentifier trust_anchor;\r\n    opaque proof_data<0..2^16-1>;\r\n} Proof;\r\n\r\nstruct {\r\n    Assertion assertion;\r\n    Proof proofs<0..2^16>;\r\n} Certificate;\r\n```\r\n\r\nThen pair with something like https://github.com/davidben/tls-trust-expressions/issues/54 so that the server has a bunch of proofs available and the client can ask for some subset of them.\r\n\r\nThings we could model this way:\r\n* Signature-like proofs where you expect multiple independent entities to attest to it\r\n* Something X.509 + CT-like where you have one signature from a domain validating entity and some signatures from logging entities\r\n* MTCs with optional signatures over the tree head when the client isn't up-to-date\r\n\r\nThis also enables somewhat more compact representations on the subscriber. The assertion will contain a big PQ key and this way you just need the one blob in memory. Or if different clients' requests overlap, you only need to keep one copy of each individual component around.\r\n\r\nOne subtlety: if one proof depends on another proof, this structure flattens it and loses the information. That would need to be sufficiently encoded into the trust anchor identifiers and/or different credentials that you get a good combination.",
      "createdAt": "2024-08-07T13:34:42Z",
      "updatedAt": "2024-08-11T17:58:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Some other subtleties:\r\n* CertificatePropertyList applies to the whole Certificate. The properties get more complicated if they have to correlate with individual proofs\r\n* Different proofs might expire at different times (e.g. MTCs have an upper bound). I'm thinking that, in #83, the expiry should be part of the Proof, with individual proofs being allowed to expire at different times\r\n\r\nOther directions:\r\n* Explode the structure in the protocol. First \"certificate\" in the TLS certificate list is the Assertion, the rest are individual Proofs\r\n* Explode the structure in the subscriber / CA bit. Abandon the assertion size optimization and say you just get a bunch of assertion + single-proof tuples, stitch them back together by looking for matching assertions",
          "createdAt": "2024-08-07T13:38:31Z",
          "updatedAt": "2024-08-07T13:38:31Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> One subtlety: if one proof depends on another proof, this structure flattens it and loses the information.\r\n\r\nWhich is the case for https://github.com/davidben/tls-trust-expressions/issues/54. However, we should think about what an analogue would look like when we have MTC in place.\r\n\r\nI'd say the CA would create a signed _promise_ that it will include a certain assertion in a future batch. One can then gather cosignatures of witnesses that will check whether the CA indeed will include the assertion is the batch. The promise is akin to the regular certificate today, and the cosignature is like an SCT.\r\n\r\nI can't quite make this fit neatly. Format of promise is alright.\r\n\r\n```\r\nstruct {\r\n    uint32 batch_number;\r\n    Signature signature;\r\n} SignedPromiseProofData;\r\n```\r\n\r\nHere `signature` is over\r\n\r\n```\r\nstruct {\r\n    TrustAnchorIdentifier anchor; // with batch number\r\n    Assertion assertion;\r\n} Promise;\r\n```\r\n\r\nPromise can use the base TrustAnchorIdentifier of the CA. (One could move the `batch_number` into the TrustAnchorIdentifier, but would need to allocate a different TrustAnchorIdentifier. I do not think that makes sense as you wouldn't want to negotiate on the promised batch number.)\r\n\r\nNegotiation for promises works nicely: servers just need to install the regular MTC proofs with higher preference over the promises.\r\n\r\nFormat of cosignatures is alright too:\r\n\r\n```\r\nstruct {\r\n   TrustAnchorIdentifier anchor; // CA that made the promise including batch number\r\n   Signature cosignature;\r\n} WitnessProofData;\r\n```\r\n\r\n`cosignature` is over `Promise` as before.\r\n\r\nThe difficulty is the negotiation. The client trusts certain witnesses and certain CAs. It wants, say, three cosignatures of trusted witnesses on the same promise. If we use a single TAI for the witness, then the negotiation of https://github.com/davidben/tls-trust-expressions/issues/54 is unsatisfactory in two ways: 1. it could return three cosignatures on promises of different CAs and ; 2. it could return cosignatures on promises of an untrusted CA.\r\n\r\nInstead of a global TAI, we could assign a separate TAI for the combination of witness and CA. (Say, simply `witness-TAI.ca-TAI`.) That solves the second problem, but not the first.",
          "createdAt": "2024-08-07T14:25:45Z",
          "updatedAt": "2024-08-07T14:25:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> Instead of a global TAI, we could assign a separate TAI for the combination of witness and CA.\r\n\r\nYeah, I've been assuming that they'd be paired up like that.\r\n\r\n> That solves the second problem, but not the first.\r\n\r\nHmm. I'm assuming the client knows the details of its policy and how they translate to TAIs, so it can request a collection of things that works correctly, given the server list in DNS or EncryptedExtensions. I.e. the server-offer, client-select flow is nice in that the client policy can be somewhat arbitrarily complicated and we don't need to express it on the wire.\r\n\r\nBut it's true that, when, the selection isn't flipped, then things get tricky. The client may not be able to fully express its policy, and then the server might not quite do the right thing, since the server does not have knowledge of all these details.\r\n\r\n(Cllllearly we need to allow the client to express an arbitrary boolean expression. \ud83d\ude09  We could call it... \"trust expressions\", except that name is already taken.)\r\n\r\nYeah, I dunno. I suspect there's more iterating on this idea to do here. Life is very easy when we flip to server-offer / client-select, but I don't know how strongly we can bank on that since the DNS stuff is so early.\r\n\r\n(For completeness, the trust expressions version of this would probably have required the multi-proof policy get backed into the trust store name itself, and then the CA would provision pre-assembled proof lists, which is a lot less flexible than assembling the proof lists on the fly.)",
          "createdAt": "2024-08-08T04:54:43Z",
          "updatedAt": "2024-08-08T04:54:43Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> But it's true that, when, the selection isn't flipped, then things get tricky. \r\n\r\nThere is another difficulty. How does the server know which witnesses to provision? At the moment it's easy, because there is essentially one global small list of trusted CT Logs. Do we really want to assume that'll continue? One solution is for clients to be happy with an SCT from a specific log, which the TLS server could fetch on demand. That doesn't quite fit with the flow. As fallback (for servers that can't fetch), a client could be happy with an annoyingly long list of SCTs.",
          "createdAt": "2024-08-08T12:51:35Z",
          "updatedAt": "2024-08-08T12:51:50Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "For a design like that, I think that's where ACME servers and CAs and whatnot come in. Their role is already to keep up with client requirements and get servers the thing they need.\r\n\r\nTLS servers fetching things on demand is an interesting idea but seems much harder to get to from where we are. Servers, quite reasonably, have a lot of reasons to not want to be directed to connect to arbitrary other servers.",
          "createdAt": "2024-08-11T17:58:42Z",
          "updatedAt": "2024-08-11T17:58:42Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "I_kwDOJIBkVc6UPQVT",
      "title": "MTC Fallback Estimates",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/89",
      "state": "OPEN",
      "author": "meyira",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "# Summary of MTC Fallback Estimates\r\nWe aim to estimate the probability of triggering the fallback to another PKI mechanism when Merkle Tree Certificates are deployed widely. We estimate the fallback probabilities from the server side by monitoring historic certificate data, checking for incorrect configurations and potential attacks that risk the client becoming out of sync.\r\n\r\n## Estimation Method\r\n\r\nWe queried all certificates since 2022-1-1 from 75 of the top 100 domains on [Radar](https://radar.cloudflare.com/domains). We will call them _top domains_. \r\nIn addition, we have queried certificates since 2022-1-1 for domains with a siphash ending in 0000. We call those domains _random domains_. Note that the statistics for those domains may have a large rate of false positives for the fallback estimations, as certificates for `random-domain.tld` are in the sample, but certificates for `www.random-domain.tld` are not. Therefore, our estimates are a rather loose upper bound, but we believe them to be useful nonetheless. \r\n\r\n## Fallback triggers\r\n\r\nWe have identified the following triggers for fallbacks so far: \r\n1. *New domains*: A new domain needs time to propagate its new tree heads. Visitors to the new domain immediately trigger the fallback mechanism until they have received the correct tree head. Since domains are not visited uniformly, a new domain may experience low traffic and therefore not trigger the fallback often. \r\n2. *Expired Certificates*: An expired certificate immediately triggers a fallback. Looking at historic data, this is the most likely fallback trigger, however, expiring certificates are a configuration problem that would be eliminated by the widespread use of MTC certificates. \r\n3. *Changes between Certification Authorities*: A change between CA authorities may indicate a movement of the domain. Looking at data where the CA did not change, we found that most renewals happen 14, 30 and 90 days before a certificate expires. Using this data, we distinguish between two cases by monitoring the _overlap_ between the certificates: \r\n    1. If the overlap is 14, 30 or 90 days (+-24 hours), we assume the change in CA is planned. \r\n    2. Otherwise, we assume the change is not planned and needs to happen immediately, e.g., due to an unplanned mitigation of the domain. This would trigger a fallback. 34% of switches of a CA would be in this edge case.  \r\n    3. Before assuming a fallback in case 3.2., we check if have another certificate for the same CA that overlaps the current certificate for >= 1s. If so, we assume again that the change was planned and we do not need the fallback. \r\n\r\n## Probability of Fallbacks \r\n\r\n| Fallback Trigger                          | Top Domains, relative | Top Domains, over 2.5 years |   Random Domains | Random Domains, over 2.5 years |\r\n| ----------------------------------------- | --------------------- | --------------------------- | ---------------- | ------------------------------ |\r\n| new domain (daily)\t                    | 0     %   | \t0     %| 0.07 %|  \t0.07 %|  \r\n| validity gaps * (over 2.5 years)  \t    | 0     %   | \t0.003 %| 0.01 %| \t3.03 %|\r\n| Irregular Domain Move (over 2.5 years)\t| 0.004 %   | \t1.1   %| 0.01 %| \t3.3  %|\r\n| Overall\t                                | 0.004 %   | \t1.1   %| 0.09 %| \t3.4  %|\r\n\r\n\r\nThe table above provides the absolute probability of triggering a fallback over 2.5 years and the relative probability, assuming it takes three days for the relying party synchronize with the correct tree heads. \r\n\r\nWe warmly welcome further possible fallback triggers. ",
      "createdAt": "2024-08-26T14:33:02Z",
      "updatedAt": "2024-08-29T18:19:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi meyira!\r\n\r\nFirst off, thanks for doing this analysis! Building performance estimates from real-world data is super useful for understanding how MTCs can operate in practice. Please forgive the length of this response; It\u2019s a bit rambly as I work out how to reason about these measurements.\r\n\r\nSo, the question I think we want to answer is something along the lines of:\r\n\u201cIn a world in which MTCs are deployed, how often, and in what circumstances do we expect the fallback to be needed for certificate validation to succeed?\u201d\r\n\r\nWhen a MTC is issued, there will be a period of time in which clients cannot validate the MTC because they have not yet received a tree head that corresponds to the batch containing this issuance (let\u2019s call this the fallback period). For convenience, we can organize clients into rough buckets:\r\n\r\n1. Clients that support MTCs and reliably receive dynamic updates containing batch heads, where the fallback period is dominated by vendor update frequency (e.g. Chrome would be something like <= 6 hours).\r\n2. Clients that support MTCs but do not receive timely dynamic updates (e.g. some enterprises that disable automatic updates but roll them out on some cadence after vetting, possibly on the scale of O(days)).\r\n3. Clients that don\u2019t support MTCs and will always need a fallback.\r\n\r\nBuckets 1 and 2 are related to fresh MTC issuance to some degree, while 3 represents an independent population whose behavior is unaffected by issuance or update cadence. Since fresh MTC issuance is difficult to measure without MTCs being widely deployed, we can attempt to infer the likelihood of fallback for bucket 1 (and bucket 2 to a lesser extent) by looking at publicly-available certificate and domain data and identifying scenarios that would force a MTC fallback:\r\n\r\n- **Brand new domains** \u2013 We can infer fresh MTC issuance for domains that didn\u2019t previously exist, but each domain experiences this ~once in their entire existence, so it\u2019s a very rough lower bound. Due to the time it generally takes for a domain to become a top domain, I expect this to be significantly more meaningful for the siphash random domains.\r\n- **Urgent re-issuance** \u2013When certificates need to be relied upon immediately after issuance, it forces even bucket 1 clients into a fallback period. This can be caused by leaf certificate compromise, sudden or unexpected CA distrust by some client, demand-based server scaling for sites where hosts cannot share existing certificates / keys, etc.\r\n- **MTC Staleness** \u2013 If a domain no longer has a time-valid MTC, all traffic will need to use a fallback authentication mechanism. This is difficult to measure right now because we don\u2019t have a good grasp on the frequency of operational issues that would lead to an inability to obtain and serve fresh MTCs.\r\n~~- **MTC Incorrectness** \u2013 If a MTC is mis-issued, or otherwise fails to validate, servers will be forced to use a fallback certificate. This is both a good and bad change over the status quo: today, servers rarely have the option of serving something other than their default certificate, but as a result, malformed or incorrect certificates are detectable immediately, where this might go unnoticed for some time in a highly automated MTC environment.~~\r\n\r\nBefore digging too far into the numbers, does this list look right? I think our ability to measure fallback today might be limited to inferring behavior about predominantly bucket 1 -type clients from a limited amount of observable data related to the above scenarios.\r\n",
          "createdAt": "2024-08-28T23:07:58Z",
          "updatedAt": "2024-08-29T18:19:29Z"
        },
        {
          "author": "meyira",
          "authorAssociation": "NONE",
          "body": "Hi, \r\nThanks for looking over the estimates and insisting on refining the criteria! I agree they are still very rough, but I wanted to get a bit of a feeling for the likeliness of triggering a fallback. \r\nThe bucket division is interesting! I agree that bucket 1 is the only one I likely can estimate, however, bucket 3 is also unlikely to check SCTs right now. For Bucket 2, the fallback probability likely depends on how much configuration MTC is going to offer to clients, and how long the cadence period is. I guess estimating bucket 2 would need an actual deployment. \r\nThe list of the criteria looks good to me, except for the MTC incorrectness: Is it expected behaviour to fall back when the MTC is malformed?",
          "createdAt": "2024-08-29T12:31:03Z",
          "updatedAt": "2024-08-29T14:39:59Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't quite follow the *MTC Incorrectness* scenario. Are you proposing that on receiving an invalid certificate, the client automatically retries asking for a different one? I don't think that's very desirable, as you indeed loose visibility into misconfigurations and other errors. This is separate from servers being able to negotiate and support multiple certificates.\r\n\r\nOn bucket 2. I'd say it makes sense to broaden this to all willing but potentially stale clients because of the network (eg. airplane, strict network firewall.) It'd be great to have better insight into such client staleness some way.\r\n\r\n",
          "createdAt": "2024-08-29T13:45:30Z",
          "updatedAt": "2024-08-29T13:45:30Z"
        },
        {
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, yes. Incorrectness actually doesn\u2019t matter for this analysis; you\u2019re right. It\u2019s a situation where having _some_ other certificate would be helpful if it were able to be negotiated but not actually useful when measuring expected MTC fallback behavior. \r\n\r\nRe: client staleness, we looked at whether this could be inferred from existing metrics but I don\u2019t think we have a great way to measure this directly today. We could likely add the relevant metrics in a A/B test but that would have to wait for prototyping and experimental rollout to gather. \r\n",
          "createdAt": "2024-08-29T14:30:14Z",
          "updatedAt": "2024-08-29T14:30:14Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "I_kwDOJIBkVc6Y1GSm",
      "title": "Rename \"subscriber\" to \"authenticating party\"",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/93",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "See https://github.com/davidben/tls-trust-expressions/issues/74",
      "createdAt": "2024-10-03T13:21:23Z",
      "updatedAt": "2024-10-03T15:52:10Z",
      "closedAt": "2024-10-03T15:52:10Z",
      "comments": []
    },
    {
      "number": 96,
      "id": "I_kwDOJIBkVc6a3JXF",
      "title": "Define a MTC trust anchor serialization",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/96",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-18T18:33:05Z",
      "updatedAt": "2024-10-18T18:33:05Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 97,
      "id": "I_kwDOJIBkVc6cY8K6",
      "title": "Default file structure for RP and AP ",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/97",
      "state": "OPEN",
      "author": "pohlm01",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Operating systems often ship a list of trusted certificates in a well-known location. The [go source code](https://go.dev/src/crypto/x509/root_linux.go) is a nice place for an overview of where Linux stores its trusted roots. It might be nice to recommend a file structure as part of the RFC as well.\r\n\r\n## Relying Party\r\nI propose the following structure for a relying party, mainly inspired by Debian/Ubuntu:\r\n\r\n```text\r\netc\r\n\u2514\u2500 ssl\r\n    \u2514\u2500 mtc\r\n        \u2514\u2500 <issuer_id>\r\n            \u251c\u2500 ca-params\r\n            \u251c\u2500 validity-window\r\n            \u2514\u2500 signature\r\n```\r\n\r\nI think the prefix of the storage location may be different per distribution. For example, `etc/ssl/mtc` for Debian and `/etc/pki/tls/mtc` for Fedora/RHEL. What is more interesting is the structure thereafter.\r\n\r\nEach CA would live in its own subdirectory with the Issuer ID (i.e., TAI/OID) as the directory name. This directory contains the CA parameters, the root hashes of the validity window, and optionally the signature over the validity window. The CA parameters would be the following binary representation:\r\n\r\n```text\r\nstruct {\r\n    TrustAnchorIdentifier   issuer;\r\n    SignatureScheme         signature_scheme;\r\n    opaque                  public_key<1..2^16-1>;\r\n    ProofType               proof_type;\r\n    uint64                  start_time;\r\n    uint64                  batch_duration;\r\n    uint64                  lifetime;\r\n    uint32                  validity_window_size;\r\n    uint64                  storage_window_size;\r\n    opaque                  http_server<1..2^16-1>;\r\n}\r\n```\r\n\r\nThe validity window would contain the batch number and all currently valid root hashes, like defined in the draft already:\r\n```text\r\nstruct {\r\n    uint32      batch_number;\r\n    TreeHead    tree_heads[validity_window_size*hash.length];\r\n} ValidityWindow;\r\n```\r\nThe signature seems optional to me. If the relying party trusts its trust services, there might not be a need to sync them as well.\r\nThis would also save quite some bandwidth, depending on how often an RP gets updated and how many CAs exist.\r\n\r\nThat is also the reason I would like to have the signature and validity window separate, as it simplifies the update service to fetch only the missing tree heads and optionally the signature.\r\n\r\nFor the CA parameters, I am not sure if all information is actually required on the RP side. At the same time, the size is not very important here, as it would get updated only occasionally. Mainly, either the validity window size or lifetime might be left out, and the HTTP server location of the CA might be irrelevant as updates should get fetched from the transparency services. \r\n\r\n## Authenticating Party\r\nFor the authenticating party, a common structure does not seem as relevant; still, it might be nice to recommend one:\r\n\r\nI propose to store the certificates the server can choose from as `<batch_number>.mtc` in separate files and reuse the same format as for the RP for the CA parameters. To my understanding, the CA parameters are only required to know when a certificate becomes invalid, but keeping the other information in the struct allows reusing a parser that was written for the RP.\r\nThe private key is necessary to authenticate the handshake. It may be stored somewhere else as well.\r\n\r\n```text\r\n<some directory>\r\n\u2514\u2500 <issuer_id>\r\n    \u251c\u2500 0.mtc\r\n    \u251c\u2500 240.mtc\r\n    \u251c\u2500 ca-params\r\n    \u2514\u2500 private-key.pem\r\n```\r\n\r\nAny comments on the proposed structure, as well as the need to include this as a recommendation, are welcome.",
      "createdAt": "2024-10-30T11:29:49Z",
      "updatedAt": "2024-11-14T10:11:57Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 99,
      "id": "I_kwDOJIBkVc6mhYC6",
      "title": "Rename transparency service?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/99",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [
        "davidben"
      ],
      "labels": [],
      "body": "The transparency service is described as a single service just for clarity, but its role can be fulfilled by whatever the relying party wants, including e.g. a quorum of multiple TSes or whatever else.\n\nThis has always been the intent of this design, but it seems folks get confused by this. Perhaps we can rename it to avoid those folks getting confused.\n\nAlso \"transparency service\" makes it sound more lofty than it really is. It's basically just a mirror (or set of mirrors) of what the CA publishes, trusted to remain accessible and not introduce split views. Maybe \"trusted mirror(s)\"?",
      "createdAt": "2025-01-16T21:06:14Z",
      "updatedAt": "2025-02-18T18:30:25Z",
      "closedAt": "2025-02-18T18:30:25Z",
      "comments": []
    },
    {
      "number": 101,
      "id": "I_kwDOJIBkVc6pOqcV",
      "title": "Give mirrors signing keys too?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/101",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "After the clarifying refactor in https://github.com/davidben/merkle-tree-certs/issues/99, and along the way to defining the actual formats, it might make sense for mirrors to have signing keys?\n\nThis does make the story for signed windows a little complicated, and now mirrors need to also have ways to identify themselves. (Probably borrow the same OIDs.)",
      "createdAt": "2025-02-07T22:17:38Z",
      "updatedAt": "2025-02-17T12:01:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "There are a few related questions. Do we want to allow the CA to publish cosignatures on the new window? In that case the mirror can act as a witness. Also, don't we want to tackle the update transparency #58 issue more head-on?",
          "createdAt": "2025-02-17T12:01:18Z",
          "updatedAt": "2025-02-17T12:01:18Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "I_kwDOJIBkVc6qIljT",
      "title": "CA publishes signed tree head over tree of batch tree heads instead of signed validity window",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/103",
      "state": "OPEN",
      "author": "lukevalenta",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This idea is mentioned in #84 in the context of allowing RPs who have been offline for a while to catch up:\n> Now, we could optimize this by using a tree structure, rather than a linear structure. Then consistency proofs are smaller and this is starting to look a lot more like vanilla CT, with all the operational challenges that entailed. The update process is still complex, but at least allows an arbitrarily out-of-date client to catch up.\n\nTo expand on this a bit, the basic idea is that the CA maintains their append-only log of batch tree heads as a Merkle tree, and publishes an [STH](https://datatracker.ietf.org/doc/html/rfc6962#section-3.5) over that tree instead of a signed validity window over only the latest batches. The only additional storage requirement for the CA is that they must maintain the right-most edge of the tree in order to append new batches to it. (As an added benefit, if a CA has been offline for a while they can skip generating validity window signatures for no-longer-valid batches. If I understand correctly, currently a CA has to publish [one signature per batch tree head](https://davidben.github.io/merkle-tree-certs/draft-davidben-tls-merkle-tree-certs.html#section-5.4-4.2.1).)\n\nWhen mirrors retrieve the CA state, they do the same thing as before, and make sure they can reconstruct all batch tree heads and the final STH from what the CA publishes. Mirrors can additionally publish the log as [static tiles](https://github.com/C2SP/C2SP/blob/main/static-ct-api.md#merkle-tree) to make it easy for clients to construct consistency and inclusion proofs.\n\nAs discussed in #84, RPs that have been offline for a while can get a succinct Merkle tree consistency proof from the mirror to catch up, instead of needing to retrieve all batch tree heads and validity windows between `old_latest_batch` and `new_latest_batch`.\n\nMonitors can also easily get a consistency proof to ensure that any long-expired batches they retrieve from a mirror are consistent with the latest STH from the mirror.\n\nAside from the the above, there are some additional benefits if the STHs are put in [tlog-checkpoint](https://github.com/C2SP/C2SP/blob/main/tlog-checkpoint.md) format (like in [static-ct](https://github.com/C2SP/C2SP/blob/main/static-ct-api.md)). This format makes it easy for mirrors to append signatures to checkpoints (#101).\n\nDepending on the RP's transparency policy, the tlog-checkpoint format also allows for interoperability with [tlog-witness](https://github.com/C2SP/C2SP/blob/main/tlog-witness.md) networks for lightweight split view protection. Witnesses keep minimal state per CA, and can add their signature to the latest checkpoint after confirming consistency with their previous latest checkpoint. (See https://blog.transparency.dev/can-i-get-a-witness-network for more context on witness networks.)",
      "createdAt": "2025-02-14T17:42:39Z",
      "updatedAt": "2025-02-18T14:43:59Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 104,
      "id": "I_kwDOJIBkVc6rA_SG",
      "title": "Default batch duration and lifetime",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/104",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "At the moment we have hourly batches with 14 day lifetimes. Those numbers are easy to think about. In practice we might want to tweak them.\n\n**Lifetime.** In the current CA/B baseline requirements, CAs are allowed to forego supporting revocation if their certificates are *short lived*. The latter is defined as less than 7 days. (Strictly speaking it's 10 days now, but that's the transitional value.) I think it makes sense to align here and use 7 days as the default lifetime.\n\n**Batch duration**. Although we don't have good data yet, I think it's safe to say that we can't expect RPs to pull new roots hourly. A batch duration of 6 hours might make more sense.",
      "createdAt": "2025-02-21T14:21:35Z",
      "updatedAt": "2025-02-21T14:21:35Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 105,
      "id": "I_kwDOJIBkVc6rwab6",
      "title": "Backdated assertions",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/105",
      "state": "CLOSED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Suppose we have a bunch of assertions queued, but forget to issue for a few hours. The current implementation puts all assertions in the most recent batch. We could also put all queued assertions in the oldest to-be-issued batch (this could backdate an assertion). Or put each assertion in the next batch for when it was accepted.\n\nThe I-D doesn't say anything about this.",
      "createdAt": "2025-02-26T13:24:27Z",
      "updatedAt": "2025-03-13T02:43:26Z",
      "closedAt": "2025-03-13T02:43:25Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "I think the draft currently says you put them in the current one by way of this procedure:\nhttps://davidben.github.io/merkle-tree-certs/draft-davidben-tls-merkle-tree-certs.html#name-issuance-queue-and-scheduli\n\nThis does mean the assertions last potentially longer than you expected, which is another reason to do #92. (I really got to go finish that.)",
          "createdAt": "2025-02-26T14:02:36Z",
          "updatedAt": "2025-02-26T14:02:36Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think the draft currently says you put them in the current one by way of this procedure: \n\nOops, you're right.\n\n> This does mean the assertions last potentially longer than you expected, which is another reason to do https://github.com/davidben/merkle-tree-certs/pull/92. (I really got to go finish that.)\n\nThat's an elegant solution.",
          "createdAt": "2025-02-26T14:04:27Z",
          "updatedAt": "2025-02-26T14:04:27Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Think this is now resolved with #92.",
          "createdAt": "2025-03-13T02:43:25Z",
          "updatedAt": "2025-03-13T02:43:25Z"
        }
      ]
    },
    {
      "number": 106,
      "id": "I_kwDOJIBkVc6s7r7t",
      "title": "Move non-MTC-specific BikeshedCertificate definition up with Assertions",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/106",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "In putting together #92, I noticed that BikeshedCertificate is presented kinda weirdly. The format is buried deep in the instructions for how to run a CA. Maybe we should pull that up with Assertions.",
      "createdAt": "2025-03-06T20:09:52Z",
      "updatedAt": "2025-03-06T20:09:52Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 107,
      "id": "I_kwDOJIBkVc6teasj",
      "title": "Mirroring nits",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/107",
      "state": "CLOSED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "1. \u00a77.1.1 (2)\n\n> Let new_latest_batch be the result and old_latest_batch be the currently mirrored value. If new_latest_batch equals old_latest_batch, finish this procedure without reporting an error.\n\nMaybe just define `old_latest_batch` to be -1 if no batch was mirrored yet.\n\n2. We should mention that the mirror checks the batch number in the signed validity window.",
      "createdAt": "2025-03-11T12:51:19Z",
      "updatedAt": "2025-03-13T09:57:47Z",
      "closedAt": "2025-03-13T09:57:47Z",
      "comments": []
    },
    {
      "number": 109,
      "id": "I_kwDOJIBkVc6t5L0s",
      "title": "not_after nits",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/109",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> If the CA has no criteria beyond the batch-wide expiration, it MAY set this value to infinity.\n\n\"infinity\" is not defined. Given libraries often use int64s for timestamps, it'd be inconvenient to use (1<<64)-1. What about just demanding `not_after` to be less than or equal the \"not_after\" of the batch? That's also consistent with the existing check for the `not_after` in `Proof`\n\n> Compute the batch's expiration time, as described in [Section 5.1](https://davidben.github.io/merkle-tree-certs/draft-davidben-tls-merkle-tree-certs.html#parameters). If this value is before the not_after field, abort this procedure with a bad_certificate error.\n\nWe should then also have a mirror check that the `not_after` of a a batch entry is within the validity interval of the batch it's in.",
      "createdAt": "2025-03-13T14:52:55Z",
      "updatedAt": "2025-04-01T17:15:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> \"infinity\" is not defined. Given libraries often use int64s for timestamps, it'd be inconvenient to use (1<<64)-1. What about just demanding not_after to be less than or equal the \"not_after\" of the batch? That's also consistent with the existing check for the not_after in Proof\n\nYeah, I figure your implementation can pick whatever max value it likes. Usual spec rules of \"do something that matches the output, you don't need to implement this exactly\".\n\n> We should then also have a mirror check that the not_after of a a batch entry is within the validity interval of the batch it's in.\n\nAh yeah, may as well. I don't think it strictly matters in that it's safe to have invalid things in a batch, as long as relying parties consistently reject it. It's no different than having, say, a syntax error somewhere in the assertion. But it's also very cheap for mirrors to refuse to re-sign it.",
          "createdAt": "2025-04-01T17:15:01Z",
          "updatedAt": "2025-04-01T17:15:01Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "I_kwDOJIBkVc6zX107",
      "title": "Size estimates are off by 1",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/112",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "I think my size estimates were off by 1? Looks like I rounded log2 down, but it should have been rounded up.\nhttps://davidben.github.io/merkle-tree-certs/draft-davidben-tls-merkle-tree-certs.html#name-size-estimates",
      "createdAt": "2025-04-21T21:50:59Z",
      "updatedAt": "2025-05-20T20:46:37Z",
      "closedAt": "2025-05-20T20:46:37Z",
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 4,
      "id": "PR_kwDOJIBkVc5MV2RT",
      "title": "Clarify time computations are done in POSIX time",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/4",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Specifically, that they are done without leap seconds. This ensures the issuance and expiration times of all batches are consistently computed.\r\n\r\nI've also moved 'Terminology and Roles' to 'Conventions and Definitions' because it probably should go there.\r\n\r\n(This is the same as what would happen if you implemented it naively, but we need to be precise in a spec.)\r\n\r\nFixes #1",
      "createdAt": "2023-03-17T22:10:07Z",
      "updatedAt": "2023-03-24T12:31:07Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "8fc2899a8369dd2ef166baee0dc1245488b7279f",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "time",
      "headRefOid": "6396096589efc539d68dd403d81552959e52665e",
      "closedAt": "2023-03-18T01:18:43Z",
      "mergedAt": "2023-03-18T01:18:43Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "a5fbe420d77be2415b3c0bc7a1d6ce915bfb452d"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "@bob-beck since we've been talking about time a lot lately.",
          "createdAt": "2023-03-17T22:10:27Z",
          "updatedAt": "2023-03-17T22:10:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5QRlto",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-17T22:15:40Z",
          "updatedAt": "2023-03-17T22:15:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJIBkVc5QRlx8",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-17T22:16:10Z",
          "updatedAt": "2023-03-17T22:16:11Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Positive integers I presume.",
              "createdAt": "2023-03-17T22:16:10Z",
              "updatedAt": "2023-03-17T22:16:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QRl18",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-17T22:16:19Z",
          "updatedAt": "2023-03-17T22:16:19Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Do you allow negative integers?",
              "createdAt": "2023-03-17T22:16:19Z",
              "updatedAt": "2023-03-17T22:16:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QRmD3",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-17T22:17:56Z",
          "updatedAt": "2023-03-17T22:17:57Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Hmm, not sure. We don't currently use them anywhere, but it's perfectly defined to add integers in integer space. Dunno, do you have a preference?",
              "createdAt": "2023-03-17T22:17:56Z",
              "updatedAt": "2023-03-17T22:17:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QRmEO",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-17T22:17:58Z",
          "updatedAt": "2023-03-17T22:17:59Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Should you move this down with the other definitions (issuance time? etc)?",
              "createdAt": "2023-03-17T22:17:59Z",
              "updatedAt": "2023-03-17T22:17:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QRmGv",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-17T22:18:15Z",
          "updatedAt": "2023-03-17T22:18:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJIBkVc5QRmV7",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-17T22:19:59Z",
          "updatedAt": "2023-03-17T22:19:59Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "What, you don't want to get a time machine and start a CA in the 1800s? :-)\r\n\r\nI suspect this should go the same way as the question below. If we want to be able to say \"10 seconds before some time\", we should probably allow negative numbers just so the operation is defined everywhere. If not, probably doesn't matter either way.",
              "createdAt": "2023-03-17T22:19:59Z",
              "updatedAt": "2023-03-17T22:19:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QRmbw",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-17T22:20:36Z",
          "updatedAt": "2023-03-17T22:20:36Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "remember that time_t is signed. ",
              "createdAt": "2023-03-17T22:20:36Z",
              "updatedAt": "2023-03-17T22:20:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QR2x6",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-18T01:12:44Z",
          "updatedAt": "2023-03-18T01:12:44Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Although this spec talks in terms of mathematical integers anyway. But yeah it seems signed is easier here.",
              "createdAt": "2023-03-18T01:12:44Z",
              "updatedAt": "2023-03-18T01:12:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QR2yx",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-18T01:13:20Z",
          "updatedAt": "2023-03-18T01:13:20Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "(Resolving to negatives allowed per other thread. It'll never actually happen but keeps the operations complete.)",
              "createdAt": "2023-03-18T01:13:20Z",
              "updatedAt": "2023-03-18T01:13:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QR2-R",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-18T01:18:29Z",
          "updatedAt": "2023-03-18T01:18:29Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "That's actually the parameters to a CA. The terminology bit is a little awkward... right now, the terminology section just defines enough terms to talk about the overview and the rest is inline. It's... probably not quite the right model. I didn't want to drop a wall of terms without how they go together, but everything inline was differently awkward so... now we have a bit of both. :-/\r\n\r\nThinking I'll leave it as-is for now, since I imagine the organization will need to change more drastically as the document evolves anyway.",
              "createdAt": "2023-03-18T01:18:29Z",
              "updatedAt": "2023-03-18T01:18:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOJIBkVc5MyN10",
      "title": "Reword the introduction slightly",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/14",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "That last bullet doesn't really fit in the list.",
      "createdAt": "2023-03-23T23:04:45Z",
      "updatedAt": "2023-03-24T12:30:53Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "a5fbe420d77be2415b3c0bc7a1d6ce915bfb452d",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "unindent",
      "headRefOid": "7d7de6d68476a3e700d6d18dca415a32bffa43d4",
      "closedAt": "2023-03-24T12:30:46Z",
      "mergedAt": "2023-03-24T12:30:46Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "932f949c3bd7d2201b8918e39a0f210e520b560d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5Q2lzQ",
          "commit": {
            "abbreviatedOid": "7d7de6d"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-24T11:10:40Z",
          "updatedAt": "2023-03-24T11:10:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 20,
      "id": "PR_kwDOJIBkVc5NiP4W",
      "title": "Clarify that we use just a single CertificateEntry",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/20",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #11",
      "createdAt": "2023-04-03T23:37:52Z",
      "updatedAt": "2023-04-04T13:30:58Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "932f949c3bd7d2201b8918e39a0f210e520b560d",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "single-cert-entry",
      "headRefOid": "9eb61e9788432b475d3523d86b1b0ebfd3e9fc9b",
      "closedAt": "2023-04-04T13:30:54Z",
      "mergedAt": "2023-04-04T13:30:54Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "94daadcb1645ad814ef3dea344a015886bbec655"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5Rtpvo",
          "commit": {
            "abbreviatedOid": "9eb61e9"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-04T12:58:26Z",
          "updatedAt": "2023-04-04T12:58:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "PR_kwDOJIBkVc5SB9wy",
      "title": "Shorten some length prefixes",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/28",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Feedback from Ilari Liusvaara on the list. I picked the lengths mostly arbitrarily. This shaves a few bytes, though it does introduce some length limits over X.509 in TLS today. (TLS uses 2^24-1 for the overall certificate structure. Within a certificate, DER gives variable-length lengths.)",
      "createdAt": "2023-06-02T19:42:24Z",
      "updatedAt": "2023-06-02T19:43:21Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "94daadcb1645ad814ef3dea344a015886bbec655",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "trim-lengths",
      "headRefOid": "70e7a9955e1af5dafc850a36c15b15a19e3dbd6e",
      "closedAt": "2023-06-02T19:43:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Actually, let me close this and do a larger PR with the rest of the comments too. I missed there were a few more.",
          "createdAt": "2023-06-02T19:43:16Z",
          "updatedAt": "2023-06-02T19:43:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 29,
      "id": "PR_kwDOJIBkVc5SCkhp",
      "title": "Shorten some length prefixes",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/29",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Feedback from Ilari Liusvaara on the list. I picked the lengths mostly arbitrarily. This shaves a few bytes, though it does introduce some length limits over X.509 in TLS today. (TLS uses 2^24-1 for the overall certificate structure. Within a certificate, DER gives variable-length lengths.)",
      "createdAt": "2023-06-02T22:33:29Z",
      "updatedAt": "2023-06-08T12:10:06Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "25f9893e67de075d9bd65725bd2df8bbf343f08c",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "trim-lengths-2",
      "headRefOid": "89db77c25e7892fcd02dab8725ec6011f27d2354",
      "closedAt": "2023-06-08T12:09:58Z",
      "mergedAt": "2023-06-08T12:09:58Z",
      "mergedBy": "bwesterb",
      "mergeCommit": {
        "oid": "8f9143829b806ad32b32c0c2ac9d9d40d111c4ed"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "One thing to ponder: if a ProofType combines X.509-style delegation (so multiple signatures) with one of the really, really large signature schemes, will 64KiB be too tight? I can't imagine actually being happy going that high, but maybe someone wants that? @bwesterb, you probably are better to judge that than me as I've been paying less attention to the sizes available.",
          "createdAt": "2023-06-05T19:29:04Z",
          "updatedAt": "2023-06-05T19:29:04Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> I can't imagine actually being happy going that high\r\n\r\nThere are signature schemes with really big public keys, but you wouldn't use those unless you don't have to send the public keys all the time.\r\n\r\nAt 128 bits security, none of the reasonable schemes will hit the limit. Even SPHINCS+ will not. It has two variants, one optimised for size (~8kB sig, 32B pk) and one for signing speed (~17kB sig, 32B pk).",
          "createdAt": "2023-06-05T21:27:16Z",
          "updatedAt": "2023-06-05T21:27:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5W8QN9",
          "commit": {
            "abbreviatedOid": "32fd2da"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-03T00:10:54Z",
          "updatedAt": "2023-06-03T00:10:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "PR_kwDOJIBkVc5SLddO",
      "title": "Properly separate hashes in Merkle tree",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/33",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #32\r\n\r\nAlso adds change log.",
      "createdAt": "2023-06-05T10:37:29Z",
      "updatedAt": "2023-06-19T22:09:16Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "8f9143829b806ad32b32c0c2ac9d9d40d111c4ed",
      "headRepository": "bwesterb/merkle-tree-certs",
      "headRefName": "issue-32",
      "headRefOid": "964607819cb617479647141586b463f987a52874",
      "closedAt": "2023-06-19T22:06:10Z",
      "mergedAt": "2023-06-19T22:06:10Z",
      "mergedBy": "bwesterb",
      "mergeCommit": {
        "oid": "690580b4d528bfd663e2f3d4df53eced8c54ceef"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5Ymtj8",
          "commit": {
            "abbreviatedOid": "9646078"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-19T16:19:45Z",
          "updatedAt": "2023-06-19T16:20:43Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I suppose it doesn't particularly matter in the end, but it is a little annoying that we have to compute these empty hashes. (Does SPHINCS+ do this too?)\r\n\r\nIs it worth a section discussing why we need to embed the level and index into everything? (I don't fully understand it myself. :-) )",
              "createdAt": "2023-06-19T16:19:45Z",
              "updatedAt": "2023-06-19T16:21:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5Ymu4n",
          "commit": {
            "abbreviatedOid": "9646078"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-19T16:24:37Z",
          "updatedAt": "2023-06-19T16:24:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJIBkVc5YoW2M",
          "commit": {
            "abbreviatedOid": "9646078"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-19T22:02:51Z",
          "updatedAt": "2023-06-19T22:02:51Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "> (Does SPHINCS+ do this too?)\r\n\r\nSPHINCS+ only has full binary trees, but if it would have something like HashEmpty, it would contextualise that hash as well.\r\n\r\n> Is it worth a section discussing why we need to embed the level and index into everything?\r\n\r\nI'll draft something for the security considerations section.\r\n\r\n> (I don't fully understand it myself. :-) )\r\n\r\nIt's to frustrate multi-target attacks.\r\n\r\nWith the old HashAssertion, any two assertions with the same hash can be used to trick any Merkle Tree CA, included at any time. This is frustrated by the context: an attacker needs to target a specific point in the tree.\r\n\r\nSimilarly if there are `2^n` nodes across all Merkle Tree CAs, then it only takes `2^(256-n)` tries to find an assertion whose old HashAssertion is one of those hashes.  Probably that's a node in the middle which doesn't make any sense if seen as a whole, but a relying party verifying an authentication path doesn't see the shape of the full tree. `2^n` is roughly the number of non-expired certs.\r\n\r\nFor HashEmpty I do not see an avenue of attack, but I also haven't convinced myself there's not.\r\n\r\nWith untruncated 256 bit hashes, all of these attacks would require significant advances in the cryptanalysis of SHA2. We could leave the contextualisation out. It's not very expensive at all, and it makes the scheme much more robust in case the hash turns out to be weaker than expected.",
              "createdAt": "2023-06-19T22:02:51Z",
              "updatedAt": "2023-06-19T22:03:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5YoXj6",
          "commit": {
            "abbreviatedOid": "9646078"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-19T22:09:16Z",
          "updatedAt": "2023-06-19T22:09:16Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "> I'll draft something for the security considerations section.\r\n\r\nFor tracking: #55 ",
              "createdAt": "2023-06-19T22:09:16Z",
              "updatedAt": "2023-06-19T22:09:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 34,
      "id": "PR_kwDOJIBkVc5SL3o_",
      "title": "Only include hash of subject_info in Assertion",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/34",
      "state": "CLOSED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Move subject_info itself to BikeshedCertificate.\r\n\r\nThis reduces the amount of data that needs to be served by CAs a lot, expecting large post-quantum public keys.\r\n\r\nOne downside is that it complicates the verification a bit: a verifier should not forget to check whether subject_info_hash matches subject_info.\r\n\r\nAlso, to keep verification simpler, we make subject_info less flexible: always expecting a hash in an assertion. We could go for a mix of hashed and unhashed subject info in the assertion, but I do not see an application yet.\r\n\r\nSee #6 ",
      "createdAt": "2023-06-05T11:48:09Z",
      "updatedAt": "2023-06-12T11:10:33Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "8f9143829b806ad32b32c0c2ac9d9d40d111c4ed",
      "headRepository": "bwesterb/merkle-tree-certs",
      "headRefName": "issue-6",
      "headRefOid": "ec533973b406dbe1e754cb36315294a77c1982c8",
      "closedAt": "2023-06-12T11:10:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Superseded by #49 ",
          "createdAt": "2023-06-12T11:10:33Z",
          "updatedAt": "2023-06-12T11:10:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5XMJDk",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T15:18:03Z",
          "updatedAt": "2023-06-05T15:18:03Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This is a little interesting with the current extensibility model (not to say that extensibility model is the right one!) because `hash` doesn't exist at this layer. I.e. imagine if we defined both `merkle_tree_sha256` and `merkle_tree_sha384`. Or `some_proof_type_without_hashes_at_all`. How would you know which hash to use? This gets extra fun when you imagine a subscriber that doesn't know about the proof type.\r\n\r\nI'd been envisioning `Assertion` becomes the thing that the subscriber understands and cares about, and the proof is the CA <-> RP communication that they're just proxying alone. You could imagine this starting life all the way at the issuance protocol too, all the way up to the CSR equivalent. (Today, CSRs, ACME newOrder requests, and certificates all carry this information in completely different forms.) The lifecycle could then be:\r\n\r\n1. The subscriber is configured to speak TLS in a certain way. It assembles the corresponding `Assertion` structure.\r\n2. Subscriber passes this `Assertion` to the CA. The CA checks this...\r\n    1. If the subscriber requests any claims it doesn't understand, return an error\r\n    2. For each claim, perform the appropriate validation.\r\n    3. (handwaiving, and I'm sure doesn't actually work for lots of reasons) Bonus points if that validation is tightly bound to the `Assertion` structure, which the subscriber can do easily because they assembled it. E.g. you could a `validation` proof type, where the proof is empty and the trust anchor is hash(assertion) (just for negotiation purposes). The subscriber's server's ability and willingness to make a TLS connection with certificate is then analogous to the tls-alpn-01.\r\n3. CA hands back a bunch of `BikeshedCertificates`. They all have the requested `Assertion` (subscriber checks this and raises an alert otherwise) but different proofs (subscriber doesn't care about the contents of this).\r\n\r\nObviously we don't actually need this flow, and I doubt it's _actually_ worth recasting all of ACME around this structure, but being able to do something like this was part of the motivation around the current structure.",
              "createdAt": "2023-06-05T15:18:03Z",
              "updatedAt": "2023-06-05T15:18:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XMRe5",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T15:32:20Z",
          "updatedAt": "2023-06-05T15:32:21Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I suppose, under this model (if we want to keep it!), we'd have the `Assertion` struct which is the general, unhashed one. But then the tree is computed over:\r\n\r\n```\r\nstruct {\r\n    SubjectType subject_type;\r\n    HashValueSHA256 subject_type_hash;\r\n    Claim claims<0..2^24-1>;\r\n} MerkleTreeAssertionSHA256;\r\n```",
              "createdAt": "2023-06-05T15:32:20Z",
              "updatedAt": "2023-06-05T15:32:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XPMqO",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T22:13:57Z",
          "updatedAt": "2023-06-05T22:13:57Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I like pulling out `Assertion` like this in the ACME flow.\r\n\r\n(Minor point: if I understand correctly, if we'd want to leave out the hash in the BikeshedCertificate, we'd have three different assertion structs: the one with the public key for the \"CSR\"; the one with the hash for the tree and CA to publish; and the one without the hash for the BikeshedCertificate.)\r\n\r\nOriginally I thought we could group almost everything we propose under MTC, except perhaps for the negotiation mechanism itself. But now it came into focus for me that you intend most of the structures to be reused by instances different from MTC. Perhaps we should name this more general system, and move the hash into it. Perhaps: `web-sha256` and have MTC be a certificate type of it `web-sha256/mtc`.",
              "createdAt": "2023-06-05T22:13:57Z",
              "updatedAt": "2023-06-05T22:13:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XPeao",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T22:46:20Z",
          "updatedAt": "2023-06-05T22:46:21Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Does the CSR one need the hash? I figured the hash would just be private to MTCs.",
              "createdAt": "2023-06-05T22:46:20Z",
              "updatedAt": "2023-06-05T22:46:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XPfbb",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T22:48:28Z",
          "updatedAt": "2023-06-05T22:48:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "CSR would need the full public key for proof-of-possession.",
              "createdAt": "2023-06-05T22:48:28Z",
              "updatedAt": "2023-06-05T22:48:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XPf1F",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T22:49:15Z",
          "updatedAt": "2023-06-05T22:49:15Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "(It's a separate question whether proof-of-possession is actually required. I'm not sure either way.)",
              "createdAt": "2023-06-05T22:49:15Z",
              "updatedAt": "2023-06-05T22:49:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XPh9z",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T22:54:16Z",
          "updatedAt": "2023-06-05T22:54:16Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Oh sure I meant that they would have the unhashed version. I.e. generic is unhashed and both CSRs and certs use unhashed. Hashed only shows up as an implementation detail of building the tree.",
              "createdAt": "2023-06-05T22:54:16Z",
              "updatedAt": "2023-06-05T22:54:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XPjE_",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T22:56:23Z",
          "updatedAt": "2023-06-05T22:56:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "> Hashed only shows up as an implementation detail of building the tree.\r\n\r\nAnd it's what the MTC CAs serve. We don't want them to have to serve all (perhaps big) public keys.",
              "createdAt": "2023-06-05T22:56:23Z",
              "updatedAt": "2023-06-06T11:30:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5Xq7h8",
          "commit": {
            "abbreviatedOid": "ec53397"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-08T22:53:13Z",
          "updatedAt": "2023-06-08T22:53:14Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Ah yeah that too. I always forget about that one, I think because we never actually defined the darn HTTP interface. :-) Anyway, my point is more that we only need two structures, not three. I think the breakdown goes:\r\n\r\n* Assertion is the one as-is. MerkleTreeAssertionSHA256 is the one with only the hash. You can compute it from Assertion by just hashing the subject.\r\n* `GET {prefix}/batch/{number}/assertions` returns a list of MerkleTreeAssertionSHA256\r\n* HashAssertion and the tree building operation takes MerkleTreeAssertionSHA256 as input\r\n* Everything else (BikeshedCertificate, issuance process, etc.) uses Assertion",
              "createdAt": "2023-06-08T22:53:13Z",
              "updatedAt": "2023-06-08T22:53:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOJIBkVc5SMAWu",
      "title": "Miscellaneous",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/43",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "1. Add Github issue numbers to TODOs.\r\n2. Correct my initials",
      "createdAt": "2023-06-05T12:10:19Z",
      "updatedAt": "2023-06-05T20:50:50Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "94daadcb1645ad814ef3dea344a015886bbec655",
      "headRepository": "bwesterb/merkle-tree-certs",
      "headRefName": "misc",
      "headRefOid": "0b9b7549827b766287be621c546178493709d9df",
      "closedAt": "2023-06-05T17:28:31Z",
      "mergedAt": "2023-06-05T17:28:31Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "25f9893e67de075d9bd65725bd2df8bbf343f08c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5XNEr3",
          "commit": {
            "abbreviatedOid": "0b9b754"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-05T17:28:08Z",
          "updatedAt": "2023-06-05T17:28:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "PR_kwDOJIBkVc5SMG8N",
      "title": "Rename window to validity window",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/44",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #21.\r\n\r\nI like plain *window* a bit better, but this is more explicit.",
      "createdAt": "2023-06-05T12:29:50Z",
      "updatedAt": "2023-06-19T22:17:42Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "690580b4d528bfd663e2f3d4df53eced8c54ceef",
      "headRepository": "bwesterb/merkle-tree-certs",
      "headRefName": "issue-21",
      "headRefOid": "77ca0c22a86770b5e6bbb8c2afe7b67e316d2fca",
      "closedAt": "2023-06-19T22:17:38Z",
      "mergedAt": "2023-06-19T22:17:38Z",
      "mergedBy": "bwesterb",
      "mergeCommit": {
        "oid": "a93a321f5ca4deee7bc7b19c4b6eefdf1f0dc38a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5XNFKj",
          "commit": {
            "abbreviatedOid": "5b8f607"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T17:29:28Z",
          "updatedAt": "2023-06-05T17:44:03Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n2. The CA collects certificate requests into a batch (see {{parameters}}) and builds the Merkle Tree and computes the tree head (see {{building-tree}}). It then signs the validity window ending at this tree head (see {{signing}}) and publishes (see {{publishing}}) the result.\r\n```",
              "createdAt": "2023-06-05T17:29:28Z",
              "updatedAt": "2023-06-05T17:44:03Z"
            },
            {
              "originalPosition": 26,
              "body": "\"validity window state\" reads funny. Since this part is informal anyway, perhaps just...\r\n\r\n```suggestion\r\n6. In an application protocol such as TLS, the relying party communicates its currently saved validity window to the subscriber.\r\n```\r\n\r\nAnd then 5 above maybe should say:\r\n\r\n> 5. The relying party periodically fetches and saves the latest validity window from the transparency service. This validity window will contain the new tree head.\r\n",
              "createdAt": "2023-06-05T17:31:19Z",
              "updatedAt": "2023-06-05T17:44:03Z"
            },
            {
              "originalPosition": 96,
              "body": "Guessing this was to line up with a block size?",
              "createdAt": "2023-06-05T17:34:47Z",
              "updatedAt": "2023-06-05T17:44:03Z"
            },
            {
              "originalPosition": 56,
              "body": "\"validity window signature\" is a bit hard for me to parse. Perhaps:\r\n\r\n```suggestion\r\n* A signature over the corresponding validity window, described in {{signing}}.\r\n```\r\n\r\nEdit: Oh, but I see \"validity window signature\" shows up in two other places in the document. We'd need to fix those too. I mean, we could just call it the \"batch's signature\", which is true. It is the signature corresponding to the batch, we just incorporate the previous batches into that signature.\r\n\r\nDunno. WDYT?",
              "createdAt": "2023-06-05T17:36:12Z",
              "updatedAt": "2023-06-05T17:44:04Z"
            },
            {
              "originalPosition": 177,
              "body": "I wonder if this could just be more efficiently written as:\r\n\r\n```suggestion\r\n* All tree hashes sent to relying parties MUST be reflected in the mirrored CA state.\r\n```",
              "createdAt": "2023-06-05T17:40:39Z",
              "updatedAt": "2023-06-05T17:44:04Z"
            },
            {
              "originalPosition": 182,
              "body": "This might be a little easier to parse:\r\n\r\n```suggestion\r\nAs discussed in {{authenticity}}, relying parties MUST ensure that any validity windows obtained were asserted by the CA. This SHOULD be done by having the transparency service forward the CA's signature, with the relying party verifying it. However, if the transparency service already maintains a trusted, authenticated channel to the relying parties (e.g. a software or root store update channel), relying parties MAY rely on the transparency service to validate the signature on their behalf, rather than sending it over this channel.\r\n```",
              "createdAt": "2023-06-05T17:42:32Z",
              "updatedAt": "2023-06-05T17:44:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XO6kM",
          "commit": {
            "abbreviatedOid": "5b8f607"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T21:39:35Z",
          "updatedAt": "2023-06-05T21:39:35Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Yeah, it fits nicely, but would be happy with 16 byte label too.",
              "createdAt": "2023-06-05T21:39:35Z",
              "updatedAt": "2023-06-05T21:39:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XO7o-",
          "commit": {
            "abbreviatedOid": "5b8f607"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T21:41:47Z",
          "updatedAt": "2023-06-05T21:41:47Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "I like window signature better. We're not going to sign other windows, are we? So perhaps just window signature?",
              "createdAt": "2023-06-05T21:41:47Z",
              "updatedAt": "2023-06-05T21:41:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5Xq4io",
          "commit": {
            "abbreviatedOid": "5b8f607"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-08T22:37:19Z",
          "updatedAt": "2023-06-08T22:37:20Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "(Marking unresolved just because it sounds like we're still deciding the terminology.)\r\n\r\nYeah, \"window signature\" would work too. My thinking around \"batch's signature\" was that just that we currently define this object by saying:\r\n\r\n> For each batch in the \"issued\" state, the CA maintains the following batch state:\r\n>\r\n> * The list of assertions certified in this batch.\r\n>\r\n> * The tree head, a hash computed over this list, described in {{building-tree}}.\r\n>\r\n> * A signature over the corresponding validity window, described in {{signing}}.\r\n\r\nAnd since we're associating it with the batch, it seems plausible to say \"the batch's signature\".\r\n\r\nTo that end, we still have a couple instances of \"validity window signature\" which is now a term without a definition. Whichever we pick, I think we want to be consistent between where it's defined and used.\r\n\r\nBut if we say the batch has a \"window signature\" and then elsewhere we say \"batch's window signature\", that works too. \"validity window signature\" would also work, I just think it's a little wordy and hard to parse. But this is a very soft preference. I don't feel very strongly and would be happy with \"validity window signature\" if that's the cleanest.",
              "createdAt": "2023-06-08T22:37:19Z",
              "updatedAt": "2023-06-08T22:37:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XuSio",
          "commit": {
            "abbreviatedOid": "5b8f607"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-09T11:18:40Z",
          "updatedAt": "2023-06-09T11:18:40Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "I think the draft has many moving parts, and `validity window signature` to my ear seems easier to understand even if it's wordy, but perhaps we should just see what people that read the draft for the first time prefer. I'm happy with either as well.",
              "createdAt": "2023-06-09T11:18:40Z",
              "updatedAt": "2023-06-09T11:19:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XuSv5",
          "commit": {
            "abbreviatedOid": "5b8f607"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-09T11:19:23Z",
          "updatedAt": "2023-06-09T11:19:23Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "(We could merge and change later again \u2014 that'll reduce merge conflicts.)",
              "createdAt": "2023-06-09T11:19:23Z",
              "updatedAt": "2023-06-09T11:19:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5Ymr-h",
          "commit": {
            "abbreviatedOid": "5b8f607"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-19T16:13:37Z",
          "updatedAt": "2023-06-19T16:13:37Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Fair enough. Okay, well if you prefer \"validity window signature\", let's stick with that. In that case, let's switch this line back to \"A validity window signature computed as described in {{signing}}.\" so we're self-consistent. (Sorry for the churn. :-( )",
              "createdAt": "2023-06-19T16:13:37Z",
              "updatedAt": "2023-06-19T16:13:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5YmsDM",
          "commit": {
            "abbreviatedOid": "a8d765c"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-19T16:13:51Z",
          "updatedAt": "2023-06-19T16:13:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJIBkVc5YoYaT",
          "commit": {
            "abbreviatedOid": "5b8f607"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-19T22:16:44Z",
          "updatedAt": "2023-06-19T22:16:44Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "> Sorry for the churn\r\n\r\nThese small details are important, and it's not perfect yet. Let's revisit it later, despite the churn :).",
              "createdAt": "2023-06-19T22:16:44Z",
              "updatedAt": "2023-06-19T22:16:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 46,
      "id": "PR_kwDOJIBkVc5ShLKl",
      "title": "Add storage window ",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/46",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It is tempting to add a new state so that an \"issued\" batch can move\r\ninto, say, \"oblivion\" (\"expired\" would be confusing.) That would however\r\ndistract from the core logic.\r\n\r\nWe still require CAs to maintain a list of all batches and its\r\nassertions, but don't require them to expose them after the storage\r\nwindow. I think that's ok.\r\n\r\nGH https://github.com/davidben/merkle-tree-certs/issues/2\r\n\r\n(Note: forked from #44)",
      "createdAt": "2023-06-08T13:05:37Z",
      "updatedAt": "2023-10-15T10:20:39Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "17c42e02fae7062dfe358915735717fdda1f3738",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "issue-2",
      "headRefOid": "1a98733c5161b66817250e12b5dfa85f482a5a34",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased.",
          "createdAt": "2023-10-15T10:20:38Z",
          "updatedAt": "2023-10-15T10:20:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5Xq47k",
          "commit": {
            "abbreviatedOid": "e9a713b"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-08T22:39:55Z",
          "updatedAt": "2023-06-08T22:44:30Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\n: An integer describing the number batches, ending at the latest batch issued, which the CA is guaranteed to serve. `storage_window_size` MUST be at least twice `validity_window_size`.\r\n```",
              "createdAt": "2023-06-08T22:39:55Z",
              "updatedAt": "2023-06-08T22:44:30Z"
            },
            {
              "originalPosition": 42,
              "body": "Does a storage window apply to the mirrors too? If not, I don't think it's possible to set up a new mirror for a CA that already exists.\r\n\r\nTo that end, I think we'd need to update the procedure for mirrors to account for this, as the current procedure assumes the CA is obligated to go back to batch number zero.",
              "createdAt": "2023-06-08T22:44:26Z",
              "updatedAt": "2023-06-08T22:44:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XuUVR",
          "commit": {
            "abbreviatedOid": "e9a713b"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-09T11:24:31Z",
          "updatedAt": "2023-06-09T11:24:31Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "\ud83d\udc4d ",
              "createdAt": "2023-06-09T11:24:31Z",
              "updatedAt": "2023-06-09T11:24:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XuV7-",
          "commit": {
            "abbreviatedOid": "e9a713b"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-09T11:28:03Z",
          "updatedAt": "2023-06-09T11:28:03Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Storage window only applies to CA as it's written now.\r\n\r\nYou mean apply to TS? For now we could say a TS is allowed to return 410 as it desires? (And have browsers or another document stipulate stricter requirements for the different use cases of TS?)",
              "createdAt": "2023-06-09T11:28:03Z",
              "updatedAt": "2023-06-09T11:28:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5f3Osm",
          "commit": {
            "abbreviatedOid": "e9a713b"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-02T14:05:38Z",
          "updatedAt": "2023-09-02T14:05:38Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Yeah, I mean that the procedure for the TS, given non-infinite storage windows, is actually kinda tricky. A new TS cannot even run the algorithm in {{single-trusted-service}} because `old_latest_batch` will be zero, and the CA won't serve the old ones.\r\n\r\nIf a TS is allowed to return 410 whenever it feels like it, that kinda defeats the purpose of a TS I think. The TS is the one that's trusted to _not_ randomly stop serving things. :-)",
              "createdAt": "2023-09-02T14:05:38Z",
              "updatedAt": "2023-09-02T14:05:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5f7xvN",
          "commit": {
            "abbreviatedOid": "e9a713b"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-04T12:59:43Z",
          "updatedAt": "2023-09-04T12:59:44Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "We're pretty thin at the moment on the requirements on TSs and in particular on monitors, but you're right that we shouldn't give them explicit leeway here.\r\n\r\nWhat about for now: once a TS serves a batch, it must keep serving it, unless it's outside of the CA's storage window.",
              "createdAt": "2023-09-04T12:59:44Z",
              "updatedAt": "2023-09-04T12:59:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5gTLMg",
          "commit": {
            "abbreviatedOid": "e9a713b"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-07T14:52:21Z",
          "updatedAt": "2023-09-07T14:52:21Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Giving them the same storage window seems reasonable. Though whatever we choose will need to be reflected into the update algorithm I mentioned.",
              "createdAt": "2023-09-07T14:52:21Z",
              "updatedAt": "2023-09-07T14:52:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5gUzVj",
          "commit": {
            "abbreviatedOid": "e9a713b"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-07T19:01:03Z",
          "updatedAt": "2023-09-07T19:01:03Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Done.",
              "createdAt": "2023-09-07T19:01:03Z",
              "updatedAt": "2023-09-07T19:01:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 47,
      "id": "PR_kwDOJIBkVc5ShOti",
      "title": "Clarify that unparsable signing inputs are still misissuance",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/47",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "GH #5",
      "createdAt": "2023-06-08T13:15:29Z",
      "updatedAt": "2023-09-07T21:01:41Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "8f9143829b806ad32b32c0c2ac9d9d40d111c4ed",
      "headRepository": "bwesterb/merkle-tree-certs",
      "headRefName": "issue-5",
      "headRefOid": "56ffd4561028813548a953632c0a09b3bf52e370",
      "closedAt": "2023-09-07T20:54:19Z",
      "mergedAt": "2023-09-07T20:54:19Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "9a3307835a17be27bf3945a2e715a9bf3234c814"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5Xq0aS",
          "commit": {
            "abbreviatedOid": "d58800d"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-08T22:13:12Z",
          "updatedAt": "2023-06-08T22:26:19Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nFurthermore, any valid signature of a CA's `public_key` that is not of the form as defined in {{signing}}, or an extension of this protocol, MUST be considered a misissuance.\r\n```",
              "createdAt": "2023-06-08T22:13:12Z",
              "updatedAt": "2023-06-08T22:26:19Z"
            },
            {
              "originalPosition": 4,
              "body": "Extremely nitpicky nitpick: \"MUST be considered misissuance\" feels like kind of a weird directive. (What does it mean if I direct you to \"consider\" something as something else?) I think something like \"CA's MUST NOT do x\" and \"this is considered a misissuance\" reads a bit better. (Then we're just saying that this document considers such behavior a misissuance, as more a definition, than a directive.)\r\n\r\nTo that end, the previous paragraph says \"To avoid this, {{parameters}} forbids the reuse of Merkle Tree CA private keys in another protocol\", which I think refers to:\r\n\r\n> To prevent cross-protocol attacks, the key used in a Merkle Tree CA MUST be unique to that Merkle Tree CA. It MUST NOT be used in another Merkle Tree CA, or for another protocol, such as X.509 certificates.\r\n\r\n{{signing}} also says:\r\n\r\n> If the CA's private key signs an input that can be interpreted as a LabeledWindow structure, the CA is considered to have [...]\r\n\r\nWDYT if, instead, we appended to the first paragraph something like:\r\n\r\n> To avoid this, {{parameters}} forbids the reuse of Merkle Tree CA private keys in another protocol. A CA MUST NOT generate signatures with its private key, except as defined in {{signing}}, or an extension of this protocol. Any valid signature of a CA's `public_key` that does not meet these requirements is considered a misissuance.\r\n\r\n(Hmm, is it \"misissuance\" if my private key gets stolen by an attacker and then the attacker generates a bad certificate, or do we use a different word for that? They're functionally equivalent, but I don't know the preferred terminology. @devonobrien )",
              "createdAt": "2023-06-08T22:24:02Z",
              "updatedAt": "2023-06-08T22:26:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XuRj4",
          "commit": {
            "abbreviatedOid": "d58800d"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-09T11:15:21Z",
          "updatedAt": "2023-06-09T11:15:21Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "sgtm, amended PR.",
              "createdAt": "2023-06-09T11:15:21Z",
              "updatedAt": "2023-06-09T11:15:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5f3OvV",
          "commit": {
            "abbreviatedOid": "d58800d"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-02T14:07:44Z",
          "updatedAt": "2023-09-02T14:07:44Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Whoops, @devonobrien and I talked about \"misissuance\" here and I learned that term is more nuanced than I thought. But I forgot to follow-up here with the conclusion, and now I've forgotten. Devon, do you remember / do you have thoughts on how to say this?",
              "createdAt": "2023-09-02T14:07:44Z",
              "updatedAt": "2023-09-02T14:07:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5gVa7U",
          "commit": {
            "abbreviatedOid": "56ffd45"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-07T20:53:58Z",
          "updatedAt": "2023-09-07T20:53:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJIBkVc5gVa_o",
          "commit": {
            "abbreviatedOid": "d58800d"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-07T20:54:11Z",
          "updatedAt": "2023-09-07T20:54:11Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "(Tweaked slightly discussing with Devon.)",
              "createdAt": "2023-09-07T20:54:11Z",
              "updatedAt": "2023-09-07T20:54:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 49,
      "id": "PR_kwDOJIBkVc5Swmms",
      "title": "Split Assertion into Assertion and AbridgedAssertion",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/49",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The latter is used in the Merkle Tree and HTTP interface. It replaces\r\n`subject_info` by a hash, to save space by not serving large\r\npost-quantum public keys. The origin Assertion is used everywhere\r\nelse, including BikeshedCertificate.\r\n\r\nSupersedes #34 \r\nCloses #6 \r\n(Also includes #33)",
      "createdAt": "2023-06-12T11:08:47Z",
      "updatedAt": "2023-10-12T14:18:19Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "6107e36ce0c2fcd610320db4955ae799a0eee65a",
      "headRepository": "bwesterb/merkle-tree-certs",
      "headRefName": "issue-6-2",
      "headRefOid": "26a544666bffc64dbe38a35373cbecdfe268f4f8",
      "closedAt": "2023-09-07T20:30:10Z",
      "mergedAt": "2023-09-07T20:30:10Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "82b4ec9106605199a6a16412e957458dc5f1432f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5f3JoD",
          "commit": {
            "abbreviatedOid": "18a3057"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-02T13:46:24Z",
          "updatedAt": "2023-09-02T14:01:12Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "```suggestion\r\n- Split Assertion into Assertion and AbridgedAssertion. The latter is used in the Merkle Tree and HTTP interface. It replaces `subject_info` by a hash, to save space by not serving large post-quantum public keys. The original Assertion is used everywhere else, including BikeshedCertificate. #6\r\n```",
              "createdAt": "2023-09-02T13:46:24Z",
              "updatedAt": "2023-09-02T14:01:12Z"
            },
            {
              "originalPosition": 5,
              "body": "Re \"For example, ...\", this isn't really a TLS-specific construction, right? We're just hashing the subject naively.\r\n\r\nAlso style nit: we haven't really been italicizing structure names. No idea what's the prevailing style, but I don't think I've seen them marked in IETF before. Though it's extra weird because we're kinda lack about \"Assertion\", the structure, and \"assertion\" the abstract word.",
              "createdAt": "2023-09-02T13:51:25Z",
              "updatedAt": "2023-09-02T14:01:12Z"
            },
            {
              "originalPosition": 24,
              "body": "Should we require and/or encourage CAs to retain the unabridged assertions so they can produce them on demand?",
              "createdAt": "2023-09-02T13:58:52Z",
              "updatedAt": "2023-09-02T14:01:12Z"
            },
            {
              "originalPosition": 36,
              "body": "Somewhere (security considerations? the Transparency section?) I think we should discuss the implications of abridged assertions. Something to the effect that it still allows domain owners to recognize unauthorized issuance. You check, for all abridged assertions with a claim that matches your domain, and if any hashes don't match one you authorized, report a misissuance even though the preimage is not available.\r\n\r\nAnd probably we should mention that, unlike CT, folks cannot search the logs for weak keys, since we've hashed them down, unless the CA provides the unabridged values somewhere. (Though given the whole point is to reduce the serving load with PQ keys...)",
              "createdAt": "2023-09-02T14:01:08Z",
              "updatedAt": "2023-09-02T14:01:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5f3Tql",
          "commit": {
            "abbreviatedOid": "18a3057"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-02T15:58:52Z",
          "updatedAt": "2023-09-02T15:58:53Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "> Re \"For example, ...\", this isn't really a TLS-specific construction, right? We're just hashing the subject naively.\r\n\r\nAt the moment we are, but we could vary that for other subject types. Reason I add TLS explicitly as an example, is that it is easier to follow: the reader might not know what *subject information* is.\r\n\r\n> we haven't really been italicizing structure names\r\n\r\nRemoved italicisation. It was meant more as emphasis instead of consistent style.",
              "createdAt": "2023-09-02T15:58:52Z",
              "updatedAt": "2023-09-02T15:58:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5f3UQh",
          "commit": {
            "abbreviatedOid": "18a3057"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-02T16:05:55Z",
          "updatedAt": "2023-09-02T16:05:55Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "For TLS it's as if we dictate that everyone can only use the replace-public-key-by-its-hash-and-put-the-public-key-together-with-the-signature transform of each signature scheme.\r\n\r\nWe do miss the opportunity to analyse (some types of) weak public keys.\r\n\r\nI don't think the latter is worthwhile to demand CAs to retain the unabridged assertions. Perhaps I missed an application of keeping them around?",
              "createdAt": "2023-09-02T16:05:55Z",
              "updatedAt": "2023-09-02T16:05:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5f3UTE",
          "commit": {
            "abbreviatedOid": "18a3057"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-02T16:07:37Z",
          "updatedAt": "2023-09-02T16:07:37Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Ah, I see you came to [the same preliminary conclusion](https://github.com/davidben/merkle-tree-certs/pull/49#discussion_r1313836002).",
              "createdAt": "2023-09-02T16:07:37Z",
              "updatedAt": "2023-09-02T16:07:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5f3UTk",
          "commit": {
            "abbreviatedOid": "18a3057"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-02T16:07:56Z",
          "updatedAt": "2023-09-02T16:07:56Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Continuing in [the other thread](https://github.com/davidben/merkle-tree-certs/pull/49#discussion_r1313834970).",
              "createdAt": "2023-09-02T16:07:56Z",
              "updatedAt": "2023-09-02T16:07:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5f3VuH",
          "commit": {
            "abbreviatedOid": "18a3057"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-02T16:38:36Z",
          "updatedAt": "2023-09-02T16:38:36Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I added some text to the security considerations section.",
              "createdAt": "2023-09-02T16:38:36Z",
              "updatedAt": "2023-09-02T16:38:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5gVDrC",
          "commit": {
            "abbreviatedOid": "ce4b188"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-07T19:43:36Z",
          "updatedAt": "2023-09-07T19:48:00Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Well, connecting to them may not work if the server is no longer presenting the keys. I also think it's worth a sentence for why we're sacrificing this. Perhaps...\r\n\r\n```suggestion\r\nOne notable difference with Certificate Transparency is that transparency services do not publish the public keys, but rather hashes of them. This is intended to reduce serving costs, particularly with large post-quantum keys. Relying partings can still detect misissuance by looking for unexpected `subject_info_hash` values. However, this optimization complicates studies of weak public keys, e.g. {{SharedFactors}}. Such studies will have to retrieve the public keys separately, such as by connecting to the TLS servers, or fetching from the CA if it retains the unabridged assertion. This document does not define a mechanism for doing this.\r\n```\r\n\r\nI left open the possibility of the CA retaining it. Since the costs are more serving than storage, I think it'd be reasonable for a CA to retain it (possibly even expect them to, but we can leave that for later), and then maybe the researcher could work with a cooperating CA to fetch it. I'm assuming a one-off fetch is fine and it's really just persistently serving that much data to be costly.\r\n\r\nDoes that seem reasonable to you? We can also drop it, but I feel like if we just say \"oh fetch it from the TLS server\", we'll immediately invite all kinds of comments that the TLS server may not be serving it anymore. We're really saying we're okay not considering this use case to be in scope.",
              "createdAt": "2023-09-07T19:43:36Z",
              "updatedAt": "2023-09-07T19:48:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5gVTKs",
          "commit": {
            "abbreviatedOid": "fa48a55"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-07T20:29:02Z",
          "updatedAt": "2023-09-07T20:29:02Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Oops, I typed \"Relying partings\" in my suggestion. Let's see if I can just fix that inline...",
              "createdAt": "2023-09-07T20:29:02Z",
              "updatedAt": "2023-09-07T20:29:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5gVTed",
          "commit": {
            "abbreviatedOid": "26a5446"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-07T20:30:04Z",
          "updatedAt": "2023-09-07T20:30:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 50,
      "id": "PR_kwDOJIBkVc5SxUoK",
      "title": "Elaborate on CA public key and signature format",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/50",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #27",
      "createdAt": "2023-06-12T12:55:38Z",
      "updatedAt": "2024-10-18T18:32:49Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "a93a321f5ca4deee7bc7b19c4b6eefdf1f0dc38a",
      "headRepository": "bwesterb/merkle-tree-certs",
      "headRefName": "issue-27",
      "headRefOid": "b508a1d500d26d061ea269197272c6cfa1c99bc5",
      "closedAt": "2024-10-18T18:32:48Z",
      "mergedAt": "2024-10-18T18:32:48Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "f74e52f630d33dcdc495de56e18af2869adbfbdb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc6NyLFb",
          "commit": {
            "abbreviatedOid": "b508a1d"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-18T18:32:44Z",
          "updatedAt": "2024-10-18T18:32:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "PR_kwDOJIBkVc5SybMI",
      "title": "Add a preliminary section in dealing with bitflips",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/51",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #26",
      "createdAt": "2023-06-12T15:36:38Z",
      "updatedAt": "2023-09-11T12:11:31Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "a93a321f5ca4deee7bc7b19c4b6eefdf1f0dc38a",
      "headRepository": "bwesterb/merkle-tree-certs",
      "headRefName": "issue-26",
      "headRefOid": "117e048581f55055a5eebd18849902837d7a4e24",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5YR_2Q",
          "commit": {
            "abbreviatedOid": "448bc9d"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-15T09:22:30Z",
          "updatedAt": "2023-06-15T09:22:31Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Given CT's ambiguity here left us in a bad spot wrt bit flips, could we refer to a strong practice or just prescribe specific steps here? e.g. Sign --> verify --> Publish or Sign1 --> Sign2 --> Compare --> Publish. Catching these before the signatures get into the wild really does reduce it to a pure availability problem.",
              "createdAt": "2023-06-15T09:22:30Z",
              "updatedAt": "2023-06-15T09:22:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5YSdrJ",
          "commit": {
            "abbreviatedOid": "448bc9d"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-15T10:28:12Z",
          "updatedAt": "2023-06-15T10:28:12Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I'm happy to add a list of suggested countermeasures. However, I don't want to seem exhaustive.",
              "createdAt": "2023-06-15T10:28:12Z",
              "updatedAt": "2023-06-15T10:28:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5gVdvV",
          "commit": {
            "abbreviatedOid": "117e048"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-07T21:03:54Z",
          "updatedAt": "2023-09-07T21:03:55Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Aren't the two cited bitflips really just analogs to these two failures? I.e., at least as currently written, we aren't any more bitflip-lenient than CT was. There is potentially some room for bitflip leniency purely on grounds that the bust trees will eventually age out, and you could imagine the TSes just refusing to forward the bust tree heads, but that feels like something different and may require some more normative text.",
              "createdAt": "2023-09-07T21:03:54Z",
              "updatedAt": "2023-09-07T21:03:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5gZBfX",
          "commit": {
            "abbreviatedOid": "117e048"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-08T10:32:46Z",
          "updatedAt": "2023-09-08T10:32:46Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "> There is potentially some room for bitflip leniency purely on grounds that the bust trees will eventually age out, and you could imagine the TSes just refusing to forward the bust tree heads\r\n\r\nIt's scary to be lenient like this, because it threatens transparency. We don't want a CA to just show a particular batch to only one tiny TS.\r\n\r\n> Aren't the two cited bitflips really just analogs to these two failures?\r\n\r\nYes and no.\r\n\r\nThe yeti2022 bit flip indeed is an example of 2, and we can't be lenient with it. The bit flip would've been caught, if the CT log would've recomputed the tree head just to be sure, as we suggest in the text.\r\n\r\nThe nessie2024 bit flip is a bit funny. It's not quite 1. The problem was that the SubjectPublicKeyInfo in the tbs_certificate didn't match the one in the pre_certificate because of a bit flip. With MTC there is no duplication: we'd just have a bit flip in the subject_info_hash. It's the subscriber's job to notice the error. If they see that hash only differs by one bit from the intended hash, then that's technically a misissuance, but one without any potential for a security breach, and we can be lenient.",
              "createdAt": "2023-09-08T10:32:46Z",
              "updatedAt": "2023-09-08T10:32:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5gamx_",
          "commit": {
            "abbreviatedOid": "117e048"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-08T14:14:31Z",
          "updatedAt": "2023-09-08T14:14:31Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "> It's scary to be lenient like this, because it threatens transparency. We don't want a CA to just show a particular batch to only one tiny TS.\r\n\r\nEven the tiny TS will detect this because the input assertions will not match the signature at the top. Your TS, large or small, should be unwilling to pass tree heads along if they weren't able to build the tree.\r\n\r\nBut, yeah, it would be a whole lot of engineering (punching holes in the update flow) and policy work when the alternative is pretty straightforward:\r\n* The update process will naturally fail to work and so the CA -> TS -> RP flow will freeze. No new certs will work but old ones are still fine\r\n* Recovery can simply be winding down the old CA and making a new one. We're already presupposing an updatable RP, so cycling CAs is very easy\r\n\r\n> It's the subscriber's job to notice the error. If they see that hash only differs by one bit from the intended hash, then that's technically a misissuance, but one without any potential for a security breach, and we can be lenient.\r\n\r\nI dunno how much we want to play the bit-flip-counting game here (also the bitflip could have happened in the middle of computing the hash, in which case it'll be a bit more of a mess). But my actual point is that nothing in this PR is special to MTCs.\r\n\r\n* In both systems, if you thought you signed something but didn't, you didn't do anything. Although, more on this below.\r\n* In both systems, if you serve some garbage instead of cryptographically coherent log state, it's an availability issue in your serving frontend\r\n* In both systems, if you issue and log a certificate just fine, but send some other byte string to the subscriber, that's between you and the subscriber. Try again at delivering your byte string.\r\n* In both systems, if you issue a certificate asserting a false thing, that's unambiguously misissuance. It's up to root programs to make a policy decision what to do here.\r\n* In both systems, if you sign the wrong or a garbage tree head, that's unambiguously a failure in the log. MTCs can contain the impacts a bit better just because each batch is independent, but from the above discussion it sounds like we're not too excited about leaning on that anyway\r\n* In both systems, double-checking computation can help if your computing environment is prone to bit flips\r\n\r\nSo I think we aren't _actually_ \"designed to be lenient with bitflips\". Which I also think is fine. It is hard to quantify the impact of a bitflip. Leaving it to a case-by-case policy decision seems the right path anyway. For example, the first claim (\"A signature that does not verify...\") is very very dangerous. If your bitflip caused you branch into the DoNothing() function instead of the SignSomething() function, that's fine. But more likely your bitflip messed up some internal computation in your signing algorithm, in which case we'd need to dig into the literature on fault attacks for your algorithm. You may well have burned your private key.\r\n\r\nSo I'm inclined to say we just don't say anything in the draft and leave it be.",
              "createdAt": "2023-09-08T14:14:31Z",
              "updatedAt": "2023-09-08T14:15:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5gjNv0",
          "commit": {
            "abbreviatedOid": "117e048"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-11T12:11:31Z",
          "updatedAt": "2023-09-11T12:11:31Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "> Even the tiny TS will detect this because the input assertions will not match the signature at the top. Your TS, large or small, should be unwilling to pass tree heads along if they weren't able to build the tree.\r\n\r\n\ud83d\udcaf \r\n\r\n> But, yeah, it would be a whole lot of engineering (punching holes in the update flow) and policy work when the alternative is pretty straightforward:\r\n> \r\n> * The update process will naturally fail to work and so the CA -> TS -> RP flow will freeze. No new certs will work but old ones are still fine\r\n\r\nThis is sensible.\r\n\r\n> * In both systems, double-checking computation can help if your computing environment is prone to bit flips\r\n\r\nThe nessie2024 bit flip would've been prevented if the computation was double checked. Whether some in an RFC will ensure all implementations will be thoughtful of bitflips is a different question.\r\n\r\n> So I think we aren't _actually_ \"designed to be lenient with bitflips\".\r\n\r\nI'm ok leaving that out. It's more important that we actually thought through where bitflips can happen and how we should deal with them.\r\n",
              "createdAt": "2023-09-11T12:11:31Z",
              "updatedAt": "2023-09-11T12:11:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 52,
      "id": "PR_kwDOJIBkVc5S97Es",
      "title": "Minor editorial changes",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/52",
      "state": "MERGED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "* Separate the list of allowed/not allowed values for `dnsname` by regular text so that `xn--iv8h.example` and `EXAMPLE.com` don't blur together\r\n* Format the `*.` string\r\n* Remove an unnecessary comma",
      "createdAt": "2023-06-14T08:55:01Z",
      "updatedAt": "2023-06-15T08:18:18Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "8f9143829b806ad32b32c0c2ac9d9d40d111c4ed",
      "headRepository": "thomwiggers/merkle-tree-certs",
      "headRefName": "patch-1",
      "headRefOid": "a3e043c4ec78971a556f9bcc94b27280fb76cbae",
      "closedAt": "2023-06-15T03:04:52Z",
      "mergedAt": "2023-06-15T03:04:52Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "af6c6bc879815c67e8f4e92c26a39588d4b68d72"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5YP_SX",
          "commit": {
            "abbreviatedOid": "a3e043c"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2023-06-15T03:04:48Z",
          "updatedAt": "2023-06-15T03:04:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 56,
      "id": "PR_kwDOJIBkVc5TbrnB",
      "title": "Remove unused definition of ||, 0x00, and 0x02",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/56",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-20T12:19:19Z",
      "updatedAt": "2023-06-20T16:46:12Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "a93a321f5ca4deee7bc7b19c4b6eefdf1f0dc38a",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "stray-def",
      "headRefOid": "14e20da17791a788e0111eacc4d5f5cd9c98aec0",
      "closedAt": "2023-06-20T16:46:08Z",
      "mergedAt": "2023-06-20T16:46:08Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "0bd4f3e98b382b80cf5f9d7ae8b63ab911b9346d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5YuePv",
          "commit": {
            "abbreviatedOid": "14e20da"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-20T16:45:58Z",
          "updatedAt": "2023-06-20T16:45:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "PR_kwDOJIBkVc5Tc57g",
      "title": "Add batch randomizer and elaborate on the security requirements from the hash",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/57",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Cf #45 #55\r\n\r\nThis does add 16 bytes to each proof. Is it worth it? Perhaps something to discuss in the working group.",
      "createdAt": "2023-06-20T15:27:28Z",
      "updatedAt": "2023-10-15T10:20:49Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "17c42e02fae7062dfe358915735717fdda1f3738",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "issue-45",
      "headRefOid": "c5f6eef9548cadb41368517841514cf1c57b6a4a",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased.",
          "createdAt": "2023-10-15T10:20:49Z",
          "updatedAt": "2023-10-15T10:20:49Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 59,
      "id": "PR_kwDOJIBkVc5TpSbJ",
      "title": "Start fleshing out HTTP interface",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/59",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #12.\r\n\r\nI tried to keep it as simple as possible.\r\n\r\nNeeds to be updated after we add the storage window. #46 \r\nSignatures are defined in #50 \r\nNeeds to be updated after merging #46, #57 and #49\r\n",
      "createdAt": "2023-06-22T11:13:29Z",
      "updatedAt": "2025-02-18T19:30:50Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "17c42e02fae7062dfe358915735717fdda1f3738",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "issue-12",
      "headRefOid": "d9f661c78ffdbb66952f2fc805d9ddf7a5c9a3f6",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased.",
          "createdAt": "2023-10-15T10:33:48Z",
          "updatedAt": "2023-10-15T10:33:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc6ccy_C",
          "commit": {
            "abbreviatedOid": "d9f661c"
          },
          "author": "lukevalenta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-18T19:30:50Z",
          "updatedAt": "2025-02-18T19:30:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "If we go with the `tlog` approach (#103), we probably want to make this the same as the submission prefix/origin line from https://github.com/C2SP/C2SP/blob/main/static-ct-api.md#checkpoints.",
              "createdAt": "2025-02-18T19:30:50Z",
              "updatedAt": "2025-02-18T19:30:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 60,
      "id": "PR_kwDOJIBkVc5TpVvT",
      "title": "Fix tree_heads definition",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/60",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The TLS presentation language brackets the size of a vector in bytes; not the number of elements. Correct and add a remark.\r\n\r\nIf we're going to use vectors more often, we might introduce ad-hoc notation for this.",
      "createdAt": "2023-06-22T11:24:20Z",
      "updatedAt": "2023-08-24T12:26:07Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "0bd4f3e98b382b80cf5f9d7ae8b63ab911b9346d",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "tree_heads-dfn",
      "headRefOid": "bf510f24ad200b7f8c1b0bdaa10cbcbd341e37ee",
      "closedAt": "2023-06-23T01:57:30Z",
      "mergedAt": "2023-06-23T01:57:30Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "261ba2367eee7279d5e8a83eb1bc790a63cee719"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5ZEPD9",
          "commit": {
            "abbreviatedOid": "bf510f2"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-23T01:57:24Z",
          "updatedAt": "2023-06-23T01:57:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 62,
      "id": "PR_kwDOJIBkVc5UnPMS",
      "title": "Specify canonical representation for assertions",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/62",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "GH #31",
      "createdAt": "2023-07-04T12:26:59Z",
      "updatedAt": "2023-07-12T23:03:04Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "261ba2367eee7279d5e8a83eb1bc790a63cee719",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "issue-31",
      "headRefOid": "3986ef0b73aeaf90a405ef356b000b5646631572",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5aK1bP",
          "commit": {
            "abbreviatedOid": "5743d2e"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-04T12:28:09Z",
          "updatedAt": "2023-07-04T12:28:09Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Also equivalent to:\r\n\r\n```python\r\ndef mtcSort(l):\r\n    return ['.'.join(reversed(x))\r\n            for x in sorted([tuple(reversed(x.split('.'))) for x in l])]\r\n```",
              "createdAt": "2023-07-04T12:28:09Z",
              "updatedAt": "2023-07-04T12:28:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5aK1zP",
          "commit": {
            "abbreviatedOid": "5743d2e"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-04T12:29:07Z",
          "updatedAt": "2023-07-04T12:29:07Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "This list is chosen such that normal sorting or sorting the reversed words will not work. Also it catches all cases in the definition.",
              "createdAt": "2023-07-04T12:29:07Z",
              "updatedAt": "2023-07-04T12:29:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 63,
      "id": "PR_kwDOJIBkVc5WFt8G",
      "title": "typo: fix layer in HashEmpty",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/63",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reported-by: Mia Celeste @mia1024",
      "createdAt": "2023-07-21T11:16:30Z",
      "updatedAt": "2023-07-21T11:48:30Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "261ba2367eee7279d5e8a83eb1bc790a63cee719",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "bas/typo",
      "headRefOid": "3edecbaa099adbec0b64a05175d5c4d94a2008ae",
      "closedAt": "2023-07-21T11:47:39Z",
      "mergedAt": "2023-07-21T11:47:39Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "de3a2940df0144b50dfb0a66c695a12a1a391ee7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5b2fL4",
          "commit": {
            "abbreviatedOid": "3edecba"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-21T11:47:27Z",
          "updatedAt": "2023-07-21T11:47:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOJIBkVc5YkeQe",
      "title": "Path is allowed to be empty",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/64",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reported-by: Mia Celeste @mia1024",
      "createdAt": "2023-08-23T08:11:23Z",
      "updatedAt": "2023-08-24T12:26:06Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "de3a2940df0144b50dfb0a66c695a12a1a391ee7",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "bas/path-fix",
      "headRefOid": "8d76417765af45e8b7daf410df12bd05f2c6a52f",
      "closedAt": "2023-08-23T13:55:40Z",
      "mergedAt": "2023-08-23T13:55:40Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "6107e36ce0c2fcd610320db4955ae799a0eee65a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5e3u2j",
          "commit": {
            "abbreviatedOid": "8d76417"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-23T13:55:29Z",
          "updatedAt": "2023-08-23T13:55:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 67,
      "id": "PR_kwDOJIBkVc5Zz9ue",
      "title": "Require lifetime to be a multiple of batch_duration. #65",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/67",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-07T19:18:25Z",
      "updatedAt": "2023-09-07T21:01:53Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "6107e36ce0c2fcd610320db4955ae799a0eee65a",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "issue-65",
      "headRefOid": "3309d45c3a596771bc22eeccc688dccad20c224b",
      "closedAt": "2023-09-07T19:35:01Z",
      "mergedAt": "2023-09-07T19:35:01Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "36de0ed4feeec8d739f299a55df2b24621c7e2f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5gVBGz",
          "commit": {
            "abbreviatedOid": "3309d45"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-07T19:34:55Z",
          "updatedAt": "2023-09-07T19:34:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 68,
      "id": "PR_kwDOJIBkVc5Zz-8k",
      "title": "Avoid the temptation of floating points",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/68",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "GH #66",
      "createdAt": "2023-09-07T19:23:45Z",
      "updatedAt": "2023-09-07T21:01:51Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "36de0ed4feeec8d739f299a55df2b24621c7e2f9",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "issue-66",
      "headRefOid": "3261e44d17ec59d7ae4f7695084639c0c19f7096",
      "closedAt": "2023-09-07T19:49:03Z",
      "mergedAt": "2023-09-07T19:49:03Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "b6857fe336db2e54aa6a72f5697e73a3d8465b2f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5gVAny",
          "commit": {
            "abbreviatedOid": "a7e27be"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-07T19:33:23Z",
          "updatedAt": "2023-09-07T19:33:24Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Very nitpicky nitpick: this reads a little clearer to me, but I don't know if this is actually the right way to phrase this, or the particular flavor of math jargon that I learned.\r\n\r\n```suggestion\r\nLet `n` be the number of input assertions. If `n > 0`, the CA builds a binary tree with l levels numbered `0` to `l-1`, where `l` is the smallest positive integer such that `n <= 2^(l-1)`. Each node in the tree contains a hash value. Hashes in the tree are built from the following functions:\r\n```",
              "createdAt": "2023-09-07T19:33:23Z",
              "updatedAt": "2023-09-07T19:33:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5gVFKI",
          "commit": {
            "abbreviatedOid": "3261e44"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-07T19:48:41Z",
          "updatedAt": "2023-09-07T19:48:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 70,
      "id": "PR_kwDOJIBkVc5Z0tLU",
      "title": "Refine the text around signatures and hashed subjects slightly",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/70",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "See issue #69.",
      "createdAt": "2023-09-07T22:57:17Z",
      "updatedAt": "2023-09-08T13:57:36Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "9a3307835a17be27bf3945a2e715a9bf3234c814",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "preimages",
      "headRefOid": "04b0fddbfd5b53eefd92103d528f8fd253813ea9",
      "closedAt": "2023-09-07T23:31:11Z",
      "mergedAt": "2023-09-07T23:31:10Z",
      "mergedBy": "bwesterb",
      "mergeCommit": {
        "oid": "dd8812d3c6ed40df4bb759ec35e80437f0147cf6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 71,
      "id": "PR_kwDOJIBkVc5Z3Bh8",
      "title": "Thank Mia",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/71",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-08T10:00:15Z",
      "updatedAt": "2023-09-08T13:37:52Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "dd8812d3c6ed40df4bb759ec35e80437f0147cf6",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "thank-mia",
      "headRefOid": "89bb0911941b6a4dbe7d5df3ac875e2cb420a550",
      "closedAt": "2023-09-08T13:37:48Z",
      "mergedAt": "2023-09-08T13:37:48Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "f45ef94023e9eb5cc8114902c8172fd83190b3d2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5gaU6b",
          "commit": {
            "abbreviatedOid": "89bb091"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-08T13:37:41Z",
          "updatedAt": "2023-09-08T13:37:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 73,
      "id": "PR_kwDOJIBkVc5Z3ELG",
      "title": "Simplify hashing by not padding to hash block size",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/73",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hashing is very fast already: we do not need the speed up, and the padding made it a bit harder to implement.\r\n\r\nGH #72",
      "createdAt": "2023-09-08T10:08:10Z",
      "updatedAt": "2023-09-08T15:52:37Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "dd8812d3c6ed40df4bb759ec35e80437f0147cf6",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "issue-72",
      "headRefOid": "b98688dc089415ac9df0b6bcbce9d3e071cc682d",
      "closedAt": "2023-09-08T14:18:50Z",
      "mergedAt": "2023-09-08T14:18:50Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "17c42e02fae7062dfe358915735717fdda1f3738"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> Hashing is very fast already\r\n\r\nIn other words, never use MTCs with SHA-3? \ud83d\ude09",
          "createdAt": "2023-09-08T14:18:29Z",
          "updatedAt": "2023-09-08T14:18:29Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Probably the right padding construction would be\r\n\r\n```\r\nstruct {\r\n    opaque issuer_id<1..32>;\r\n    uint32 batch_number;\r\n    opaque pad[N];\r\n    uint8 distinguisher = ...;\r\n    ...\r\n```\r\n\r\nThat way you can feed the first block into your hash context once and then clone the hash context for all the subsequent bits. Previously we needed to freeze three different ones.",
          "createdAt": "2023-09-08T14:20:50Z",
          "updatedAt": "2023-09-08T14:20:50Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> In other words, never use MTCs with SHA-3? \ud83d\ude09\r\n\r\nshush!",
          "createdAt": "2023-09-08T15:52:37Z",
          "updatedAt": "2023-09-08T15:52:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5gaoue",
          "commit": {
            "abbreviatedOid": "b98688d"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-08T14:18:44Z",
          "updatedAt": "2023-09-08T14:18:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 74,
      "id": "PR_kwDOJIBkVc5Z4bv9",
      "title": "Fix typo",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/74",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-08T14:05:25Z",
      "updatedAt": "2023-09-08T14:16:14Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "f45ef94023e9eb5cc8114902c8172fd83190b3d2",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "thank-mia",
      "headRefOid": "b396663b700ac11a592da50a3bebbb9a7b262241",
      "closedAt": "2023-09-08T14:16:09Z",
      "mergedAt": "2023-09-08T14:16:09Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "ea8d11439b82c74059ca233e256661cba274c277"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5gangp",
          "commit": {
            "abbreviatedOid": "b396663"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-08T14:16:03Z",
          "updatedAt": "2023-09-08T14:16:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 77,
      "id": "PR_kwDOJIBkVc5cua1j",
      "title": "Split subject_info into ~ and abridged_subject_info",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/77",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "GH #76",
      "createdAt": "2023-10-13T10:33:24Z",
      "updatedAt": "2024-09-19T12:17:09Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "17c42e02fae7062dfe358915735717fdda1f3738",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "issue-76",
      "headRefOid": "634c9780a1757c0536e1d67ddca9d6a788753115",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Sorry, I realized https://github.com/davidben/merkle-tree-certs/issues/76#issuecomment-1759724011 was probably ambiguous. I meant I think the it's useful to have a logical separation between the TLS-specific TLSSubjectInfo format and the (so far) SubjectType-agnostic MTC format. E.g. it means you can define a new SubjectType without having to update every MTC implementation.\r\n\r\nThough it does mean the log doesn't tell you everyone's key types. Dunno how much to weigh that. WDYT?",
          "createdAt": "2023-10-16T03:04:41Z",
          "updatedAt": "2023-10-16T03:04:41Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> E.g. it means you can define a new SubjectType without having to update every MTC implementation.\r\n\r\nI don't quite follow. The difference is that with this change, you need an up-to-date implementation to abridge an assertion.\r\n\r\nTSes and monitors don't abridge (they only deal with already abridged assertions); CAs shouldn't deal with subjects they don't support; and subscribers don't care about subjects they don't support. That leaves the relying party: it can't verify the proof in a BikeshedCertificate without being updated. Does that matter though: presently it can, but what use is that proof if part of the statement proven (subject)  is not understood anyway.",
          "createdAt": "2023-10-16T09:59:29Z",
          "updatedAt": "2023-10-16T09:59:29Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Ah that's true. The TS doesn't actually care. Still, imagine if you're using a BikeshedCertificate verifier from the OS or so. Or even if not from the OS, some separate library. A SubjectType-agnostic abridging process would mean you can freely introduce new subject types (i.e. new protocols) without any fuss.\r\n\r\nAs an analogy, we don't need to patch our X.509 verifiers to introduce new EKUs. (Although EKUs are kind of a mess for other reasons, so new protocols tend not to make new ones. That's not great for cross-protocol purposes. Would be nice to avoid those reuse pressures.)",
          "createdAt": "2023-10-16T11:10:19Z",
          "updatedAt": "2023-10-16T11:10:19Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> Still, imagine if you're using a BikeshedCertificate verifier from the OS or so.\r\n\r\nFair point. The user can pass an AbridgedMerkleTreeCertificate defined in the obvious way though.\r\n\r\nNote that we do have to change the OS certificate API to support MTC, as the relying party needs to fetch the latest available batches for negotiation. Thus we have some extra flexibility there if you don't like abridging the cert.\r\n\r\nA different path is to split SubjectInfo in two in a different place. Have a HiddenTLSSubjectInfo, and a TransparentTLSSubjectInfo. Then we define a (unabridged) SubjectInfo as a pair of them, and an AbridgedSubjectInfo as the hash of the former, and the full info of the latter. Conceptually this is elegant, but it feels like unnecessary complexity and is messy to present.",
          "createdAt": "2023-10-16T11:51:22Z",
          "updatedAt": "2023-10-16T11:51:22Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Right, so I guess the question is how much of a big deal is it that the whole SubjectInfo gets hashed right now. If it's not that big of a deal (we just lose the key type), just hashing the whole thing is most straightforward.\r\n\r\nThis is roughly analogous to whether you hash the whole SPKI in X.509 or just the BIT STRING inside it.",
          "createdAt": "2023-10-16T12:21:35Z",
          "updatedAt": "2023-10-16T12:21:35Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "It'd be nice to be able to track the transition to PQ (see also #38 for the \"if you understand PQ, don't trust this extension\"), but it's not a blocker. I'm worried it's premature to assume we'll never want transparency on any part of the subject.",
          "createdAt": "2023-10-16T12:45:41Z",
          "updatedAt": "2023-10-16T12:45:41Z"
        },
        {
          "author": "pohlm01",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bwesterb and @davidben did you have the chance to develop an opinion on whether this PR will likely be merged? [bwesterb/mtc](https://github.com/bwesterb/mtc) currently implements this PR, and I wonder if I should follow this for [my implementation](https://github.com/pohlm01/mtc-verifier).",
          "createdAt": "2024-09-19T09:13:09Z",
          "updatedAt": "2024-09-19T09:31:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc6J-reF",
          "commit": {
            "abbreviatedOid": "634c978"
          },
          "author": "pohlm01",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-19T09:05:35Z",
          "updatedAt": "2024-09-19T09:05:35Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Is there a reason this is a (length prefixed) array? If I'm not mistaken, the `abridged_subject_info` has a fixed length implied by the CA parameters hash length, so don't see a need for the length prefix. I also don't see a reason to put multiple elements.",
              "createdAt": "2024-09-19T09:05:35Z",
              "updatedAt": "2024-09-19T09:05:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6KAYfE",
          "commit": {
            "abbreviatedOid": "634c978"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-19T12:14:17Z",
          "updatedAt": "2024-09-19T12:14:17Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "For TLS it's fixed length at the moment. For other subjects types it might not be fixed length; and for TLS it might even change, see #38. ",
              "createdAt": "2024-09-19T12:14:17Z",
              "updatedAt": "2024-09-19T12:14:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6KAaAV",
          "commit": {
            "abbreviatedOid": "634c978"
          },
          "author": "pohlm01",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-19T12:17:09Z",
          "updatedAt": "2024-09-19T12:17:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Ah, thanks for clarification!",
              "createdAt": "2024-09-19T12:17:09Z",
              "updatedAt": "2024-09-19T12:17:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 78,
      "id": "PR_kwDOJIBkVc5cwNSF",
      "title": "Add examples of (Abridged)Assertion",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/78",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Depends on #77 \r\n\r\nGenerated from https://github.com/bwesterb/mtc/blob/main/mtc_test.go",
      "createdAt": "2023-10-13T15:56:58Z",
      "updatedAt": "2024-07-26T17:25:38Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "17c42e02fae7062dfe358915735717fdda1f3738",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "examples",
      "headRefOid": "23daf43baf4e8fb56dfa1b30853f1de0929533a7",
      "closedAt": "2024-07-26T17:25:34Z",
      "mergedAt": "2024-07-26T17:25:34Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "d7e2917521b17816aadbc113867a841527d18e77"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 82,
      "id": "PR_kwDOJIBkVc5gKBEs",
      "title": "Specify the batch_number for placeholder tree heads",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/82",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #81",
      "createdAt": "2023-11-22T17:35:29Z",
      "updatedAt": "2023-11-22T17:50:00Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "17c42e02fae7062dfe358915735717fdda1f3738",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "issue-81",
      "headRefOid": "9a96eaa7c868c15b54eacebd144252b3aa106196",
      "closedAt": "2023-11-22T17:49:55Z",
      "mergedAt": "2023-11-22T17:49:55Z",
      "mergedBy": "bwesterb",
      "mergeCommit": {
        "oid": "c3faa0c4d1636a6046bbc1f7d084a39df3d4c71d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5oAvpH",
          "commit": {
            "abbreviatedOid": "9a96eaa"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-22T17:49:47Z",
          "updatedAt": "2023-11-22T17:49:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 87,
      "id": "PR_kwDOJIBkVc52mhN9",
      "title": "Rebase the draft on top of draft-beck-tls-trust-anchor-ids",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/87",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [
        "bwesterb",
        "devonobrien"
      ],
      "labels": [],
      "body": "The main changes:\r\n\r\n* ProofType is gone and now implicit from the trust anchor\r\n\r\n* TrustAnchor is gone and replaced with TrustAnchorIdentifier from draft-beck-tls-trust-anchor-ids.\r\n\r\n* The negotiation mechanism is removed and instead references draft-beck-tls-trust-anchor-ids, adding some guidance on how to use it.\r\n\r\n* We did lose the aliases mechanism and instead take a harder dependency on the DNS mechanism in draft-beck-tls-trust-anchor-ids. I've filed https://github.com/davidben/tls-trust-expressions/issues/62 to track restoring that.\r\n\r\n* General discussion on agility is removed as draft-beck-tls-trust-anchor-ids covers that.\r\n\r\n* Just to get it out of the way, I moved the discussion on client certificate types to an appendix.\r\n\r\nFixes #80",
      "createdAt": "2024-07-26T17:10:01Z",
      "updatedAt": "2024-08-11T23:44:44Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "d7e2917521b17816aadbc113867a841527d18e77",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "trust-anchor-ids",
      "headRefOid": "7eee5d2ed6587ca0fe8ac14fa794a3b4562aaf4b",
      "closedAt": "2024-08-11T23:44:40Z",
      "mergedAt": "2024-08-11T23:44:40Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "a891b0369725f7bce42dc9e5e4cdb34c51bb2d9a"
      },
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Bit of a nit, but why\r\n\r\n```\r\nstruct {\r\n    TrustAnchorIdentifier trust_anchor;\r\n    opaque proof_data<0..2^16-1>;\r\n} Proof;\r\n\r\nstruct {\r\n    Assertion assertion;\r\n    Proof proof;\r\n} BikeshedCertificate;\r\n```\r\n\r\nand not directly\r\n\r\n```\r\nstruct {\r\n    Assertion assertion;\r\n    TrustAnchorIdentifier trust_anchor;\r\n    opaque proof_data<0..2^16-1>;\r\n} BikeshedCertificate;\r\n```\r\n\r\nYou could say the `proof_data` doesn't make sense without the `trust_anchor`, but the `proof_data` also doesn't make sense without the `assertion`.",
          "createdAt": "2024-08-06T12:34:39Z",
          "updatedAt": "2024-08-06T12:35:07Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "@bwesterb Somewhat looking forward to maybe doing something like https://github.com/davidben/tls-trust-expressions/issues/54, but yeah, let's inline it for now.\r\n\r\n(I was OOO last week. Will take a pass to update this and look it over again.)",
          "createdAt": "2024-08-07T03:38:08Z",
          "updatedAt": "2024-08-07T03:38:08Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> @bwesterb Somewhat looking forward to maybe doing something like [davidben/tls-trust-expressions#54](https://github.com/davidben/tls-trust-expressions/issues/54), but yeah, let's inline it for now.\r\n\r\nI don't see how that'd work, but let's keep it as is then if you have something in mind.\r\n",
          "createdAt": "2024-08-07T12:48:56Z",
          "updatedAt": "2024-08-07T12:48:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Sketched it out in https://github.com/davidben/merkle-tree-certs/issues/88",
          "createdAt": "2024-08-07T13:34:53Z",
          "updatedAt": "2024-08-07T13:34:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc6DROnP",
          "commit": {
            "abbreviatedOid": "9be61be"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-26T17:15:19Z",
          "updatedAt": "2024-07-26T17:15:19Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Self-review: this and step 7 should be part of the generic process, not the issuer-specific process.",
              "createdAt": "2024-07-26T17:15:19Z",
              "updatedAt": "2024-07-26T17:15:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6DSzCc",
          "commit": {
            "abbreviatedOid": "a9afb28"
          },
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-26T20:58:09Z",
          "updatedAt": "2024-07-26T20:58:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJIBkVc6DZ1-1",
          "commit": {
            "abbreviatedOid": "a9afb28"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-29T10:49:07Z",
          "updatedAt": "2024-07-29T10:49:07Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "You don't define the wire format `TrustAnchorIdentifier`.",
              "createdAt": "2024-07-29T10:49:07Z",
              "updatedAt": "2024-07-29T10:49:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6DZ3Ix",
          "commit": {
            "abbreviatedOid": "a9afb28"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-29T10:51:46Z",
          "updatedAt": "2024-07-29T10:51:47Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Sorry, you do. If I understand correctly this is an ASN.1 oid and so needs byte-for-byte processing. Because of that it might be better to put after `proof_data` which is length prefixed?",
              "createdAt": "2024-07-29T10:51:47Z",
              "updatedAt": "2024-07-29T10:51:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6DZ7am",
          "commit": {
            "abbreviatedOid": "a9afb28"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-29T11:00:12Z",
          "updatedAt": "2024-07-29T11:00:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJIBkVc6DaeSp",
          "commit": {
            "abbreviatedOid": "a9afb28"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-29T12:12:16Z",
          "updatedAt": "2024-07-29T12:12:16Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Oh yeah, that's confusing. It's intended to be `TrustAnchorIdentifier` from here:\r\nhttps://davidben.github.io/tls-trust-expressions/draft-beck-tls-trust-anchor-ids.html#name-overview\r\n\r\nProbably we should just copy-paste the definition and write it as:\r\n```\r\n/* See Section 4.1 of draft-beck-tls-trust-anchor-ids */\r\nopaque TrustAnchorIdentifier<1..2^8-1>;\r\n```\r\n",
              "createdAt": "2024-07-29T12:12:16Z",
              "updatedAt": "2024-07-29T12:12:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6FCE57",
          "commit": {
            "abbreviatedOid": "a9afb28"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-11T23:42:50Z",
          "updatedAt": "2024-08-11T23:42:50Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Done.",
              "createdAt": "2024-08-11T23:42:50Z",
              "updatedAt": "2024-08-11T23:42:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 90,
      "id": "PR_kwDOJIBkVc57TvNp",
      "title": "Corrects test vectors based on a wrong length encoding of the DNS name",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/90",
      "state": "MERGED",
      "author": "pohlm01",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See bwesterb/mtc#2 and bwesterb/mtc#4",
      "createdAt": "2024-09-12T13:53:44Z",
      "updatedAt": "2024-09-13T07:47:34Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "a891b0369725f7bce42dc9e5e4cdb34c51bb2d9a",
      "headRepository": "pohlm01/merkle-tree-certs",
      "headRefName": "fix-test-vectors",
      "headRefOid": "d6d1a3b46c0bb56be0c167ea20feb4f26f3623ef",
      "closedAt": "2024-09-12T15:30:17Z",
      "mergedAt": "2024-09-12T15:30:17Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "32322fe424030f83bf4c69dad3a56347637989b0"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Thanks!",
          "createdAt": "2024-09-12T15:30:23Z",
          "updatedAt": "2024-09-12T15:30:23Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc6JIfwq",
          "commit": {
            "abbreviatedOid": "d6d1a3b"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-12T15:30:00Z",
          "updatedAt": "2024-09-12T15:30:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 91,
      "id": "PR_kwDOJIBkVc57irGj",
      "title": "Consistently use TAI instead of issuer_id",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/91",
      "state": "MERGED",
      "author": "pohlm01",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I suggest replacing current `opaque issuer_id<1..32>;` fields with the new `TrustAnchorIdentifier trust_anchor;`. Alternatively, we would need to adopt the maximal number of bytes to  `opaque issuer_id<1..255>;`.",
      "createdAt": "2024-09-15T12:28:48Z",
      "updatedAt": "2024-09-17T14:38:42Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "32322fe424030f83bf4c69dad3a56347637989b0",
      "headRepository": "pohlm01/merkle-tree-certs",
      "headRefName": "main",
      "headRefOid": "e07091411e6df9029adffe823617470df94e3208",
      "closedAt": "2024-09-17T14:38:41Z",
      "mergedAt": "2024-09-17T14:38:41Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "ce779c60c77cce4d2d0679d268ba979af6fa41ae"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> Thanks! Left some minor wording change which I'll just go ahead and apply and merge.\r\n\r\n...or not? Apparently I forgot to reload the page. Let's try that again...",
          "createdAt": "2024-09-17T14:32:19Z",
          "updatedAt": "2024-09-17T14:32:19Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc6JaQCB",
          "commit": {
            "abbreviatedOid": "89ce6fd"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-15T13:18:39Z",
          "updatedAt": "2024-09-15T13:18:39Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Oops, nice catch! Thanks! This was just a mistake in rebasing over TAI.\r\n\r\nLooks like the text down in line 562 needs to be updated since they refer to the structures. Same with line 627. It's a bit awkward because {{parameters}} and {{identifying}} still call it an `issuer_id`, but then the structures all say `trust_anchor`. Probably that should be renamed to be consistent across the board.\r\n\r\n(Do you mind fixing that in this PR? If not, I can merge this and then finish it up.)",
              "createdAt": "2024-09-15T13:18:39Z",
              "updatedAt": "2024-09-15T13:18:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6JaQ28",
          "commit": {
            "abbreviatedOid": "89ce6fd"
          },
          "author": "pohlm01",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-15T13:37:10Z",
          "updatedAt": "2024-09-15T13:37:10Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "While applying the changes you proposed, I noticed that we might also remove the batch number from the `Hash...` structs altogether, and require the trust anchor to identify the specific batch. See [0e5eeca](https://github.com/davidben/merkle-tree-certs/pull/91/commits/0e5eecad5dc6d2cdbfa24b1ef7f47c60c01a2187). Let me know if you like the suggestion.\r\n\r\nIndependent of that, I'm a bit worried that it became easy to confuse when to use the CA specific TAI and when a batch specific TAI is required, i.e., if the batch number is included in the TAI. Maybe it is worth making this a bit clearer in a later change. I'm not sure if it is actually required, though, and how to do this discrimination elegantly.",
              "createdAt": "2024-09-15T13:37:10Z",
              "updatedAt": "2024-09-15T13:37:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6JaTdB",
          "commit": {
            "abbreviatedOid": "0e5eeca"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-15T14:38:13Z",
          "updatedAt": "2024-09-15T14:42:40Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nThe `trust_anchor` is set to the batch-specific trust anchor identifier, i.e. with the batch number appended as described in {{identifying}}.\r\n```\r\n\r\n(Just to use the same wording.)",
              "createdAt": "2024-09-15T14:38:14Z",
              "updatedAt": "2024-09-15T14:42:40Z"
            },
            {
              "originalPosition": 23,
              "body": "> Independent of that, I'm a bit worried that it became easy to confuse when to use the CA specific TAI and when a batch specific TAI is required, i.e., if the batch number is included in the TAI. Maybe it is worth making this a bit clearer in a later change. I'm not sure if it is actually required, though, and how to do this discrimination elegantly.\r\n\r\nHmm, that is a good point. One thought: what if we continue to call the CA-specific ID the `issuer_id` or perhaps the `ca_id` and then the batch-specific ID is called the `batch_id`? Since `BikeshedCertificate` is meant to be extensible, that probably needs to say `trust_anchor` with prose saying something like:\r\n\r\n> A proof's `trust_anchor` field is a trust anchor identifier (see {{Section 3 of !I-D.beck-tls-trust-anchor-ids}} and {{Section 4.1 of !I-D.beck-tls-trust-anchor-ids}}), which determines the proof's type and issuer. It is analogous to an X.509 trust anchor's subject name. When the issuer is a Merkle Tree CA, the `trust_anchor` is a batch's `batch_id`, as described in {{identifying}}.\r\n\r\nAnd then all the MTC-specific structures can say `issuer_id` or `batch_id` depending on which it's meant to be. WDYT?",
              "createdAt": "2024-09-15T14:42:31Z",
              "updatedAt": "2024-09-15T14:42:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6JaYib",
          "commit": {
            "abbreviatedOid": "89ce6fd"
          },
          "author": "pohlm01",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-15T15:43:20Z",
          "updatedAt": "2024-09-15T15:43:20Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Sounds reasonable to me. I updated the PR to include `issuer_id` and `batch_id` where appropriate. I hope it is consistent.",
              "createdAt": "2024-09-15T15:43:20Z",
              "updatedAt": "2024-09-15T15:43:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6JrvPJ",
          "commit": {
            "abbreviatedOid": "6217110"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks! Left some minor wording change which I'll just go ahead and apply and merge.",
          "createdAt": "2024-09-17T14:29:38Z",
          "updatedAt": "2024-09-17T14:31:34Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nWhen the issuer is a Merkle Tree CA, the `trust_anchor` is a batch's `batch_id`, as described in {{identifying}}.\r\n```",
              "createdAt": "2024-09-17T14:29:38Z",
              "updatedAt": "2024-09-17T14:31:34Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nAn individual batch from a Merkle Tree CA also has an associated trust anchor identifier, called a `batch_id`. It is determined by appending the batch number, as an OID component, to the CA's `issuer_id`.\r\n```",
              "createdAt": "2024-09-17T14:30:23Z",
              "updatedAt": "2024-09-17T14:31:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6Jry6w",
          "commit": {
            "abbreviatedOid": "6217110"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "(Attempt number 2 to do it from the web interface.)",
          "createdAt": "2024-09-17T14:35:01Z",
          "updatedAt": "2024-09-17T14:35:44Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nAn individual batch from a Merkle Tree CA also has an associated trust anchor identifier, called a `batch_id`. It is determined by appending the batch number, as an OID component, to the CA's `issuer_id`.\r\n```",
              "createdAt": "2024-09-17T14:35:01Z",
              "updatedAt": "2024-09-17T14:35:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6Jrzs0",
          "commit": {
            "abbreviatedOid": "39b6d39"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-17T14:36:09Z",
          "updatedAt": "2024-09-17T14:36:09Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "(Looks like you already did this one.)",
              "createdAt": "2024-09-17T14:36:09Z",
              "updatedAt": "2024-09-17T14:36:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6Jrz6R",
          "commit": {
            "abbreviatedOid": "6217110"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-17T14:36:28Z",
          "updatedAt": "2024-09-17T14:36:28Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "applied.",
              "createdAt": "2024-09-17T14:36:28Z",
              "updatedAt": "2024-09-17T14:36:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 92,
      "id": "PR_kwDOJIBkVc58GRCf",
      "title": "Add an explicit not_after time to the Proof",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/92",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This serves two purposes:\r\n\r\n1. It allows a subscriber to easily know when the certificate is expired, without defining a separate certificate property.\r\n\r\n2. It allows a subscriber to request a shorter expiration time than the batch would otherwise force. Fixes #83.\r\n\r\nIn looking at this, I realized that the document's organization is a bit all over the place. Maybe we should just pull the generic BikeshedCertificate parts out into their own section. But for now I'm leaving the overall structure as-is.",
      "createdAt": "2024-09-19T22:38:00Z",
      "updatedAt": "2025-03-13T02:43:06Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "fb6edac3f2fbe769500e1c86a665ecec95dcc376",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "expiry",
      "headRefOid": "2f19b5b5bb28fa24ef9a8aaada4c43a0e29025a1",
      "closedAt": "2025-03-13T02:43:03Z",
      "mergedAt": "2025-03-13T02:43:03Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "fc013fb7e878f849e6163b3f1e703ebafadfd264"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Some notes and philosophizing:\r\n\r\n**not_after vs batch expiration time** \r\n\r\nWe could either have `not_after` be a constraint on top of what the batch would impose, with the relying party checking the minimum of the two, or say that `not_after` must be consistent with batch expiry, with the relying party rejecting the certificate if inconsistent.\r\n\r\nPut another way, is `not_after` the subscriber-requested expiry, or the effective expiry?\r\n\r\nI went with effective expiry because this means the subscriber does not need to know anything about the trust anchor to know when the certificate expires. Either it expires at the `not_after` time, or it was simply invalid and will be rejected at any time.\r\n\r\n**Proof vs Assertion vs Certificate**\r\n\r\n`not_after` could be part of the Assertion, part of the Proof, or just an extra field in the Certificate.\r\n\r\nI think the litmus test for being part of the Assertion is \"would you put this in a CSR?\", and the answer is I think no. \"example.com's key is 1234\" is a fact about the world. A certificate is the CA making a point-in-time claim that the fact about the world is true.\r\n\r\nNow, it being a point-in-time claim is kind of interesting. A CA that issues 14 day certificates and a CA that issues 1 year certificates do not actually perform different validation procedures. It's not like either CA has any better ability to make predictions about the future. So that might suggest that expiration times are all nonsense and maybe we should just say when the certificate was issued, with expiry being a relying party policy?\r\n\r\nExcept that's not only impractical but also doesn't capture some things. While expiry doesn't tell you anything about the validation process, it tells you how the whole ecosystem will manage this lifecycle of this certificate:\r\n\r\n* Until a certificate expires, CAs need to revoke the certificate if the fact stops being true\r\n* Until a certificate expires, subscribers need to request the certificate be revoked if the want clients to reject the fact (namely if the key material were compromised)\r\n* Until a certificate expires, subscribers should pay attention to it when monitoring transparency logs\r\n* Until a certificate expires, subscribers can reasonably serve it in preference to a newer but larger certificate\r\n\r\nBut that further reenforces that expiry is not inherent to the fact itself, but is specific how one certificate is managed.\r\n\r\nProof vs extra field in the Certificate is kind of meaningless right now. I think the litmus test is, if we end up doing #88, would it be a per-Proof or per-Certificate value? Because this is an effective expiry, I think the answer is per-Proof. Different MTC CAs may force different `not_after` dates, etc. ",
          "createdAt": "2024-09-19T22:47:43Z",
          "updatedAt": "2024-09-19T22:50:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Another random thought / justification\r\n\r\n**Opaque vs part of framework**\r\n\r\nWe could either make it part of the BikeshedCertificate framework, or make it something that you put in the specific proof type. Ultimately these are mostly isomorphic. If something is specific to the proof type, subscribers can't read it generically, but then we can define a certificate property that they _do_ know how to read.\r\n\r\nBut since subscribers should always be able to read this, and these kinds of offline assertions are inherently related to time, putting it in the framework made sense.",
          "createdAt": "2024-09-19T22:52:57Z",
          "updatedAt": "2024-09-19T22:52:57Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Some more things to ponder:\r\n\r\n1. How does a subscriber request the earlier expiration? Previously, the client would just send an assertion as assertion-publishing-request. Now we need a `AssertionSigningRequest` different from an Assertion that contains the expiry.\r\n\r\n2. Do we need a timestamp or can we use batches are granularity?\r\n\r\n3. Maybe also good to ponder revocation again. Depending on how we solve that, we might achieve what we want, by issuing and then immediately revoking for a set time. #41 \r\n",
          "createdAt": "2024-09-23T12:04:58Z",
          "updatedAt": "2024-09-23T12:04:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> How does a subscriber request the earlier expiration? Previously, the client would just send an assertion as assertion-publishing-request. Now we need a AssertionSigningRequest different from an Assertion that contains the expiry.\r\n\r\nOh ACME already has this. That was the original inspiration for this.\r\nhttps://www.rfc-editor.org/rfc/rfc8555.html#section-7.1.3\r\n\r\nNot sure how much CAs actually pay attention to this today but, in principle, it seems reasonable for a subscriber to say \"however long you issue certs for, I don't want to be vulnerable to this key for more than 24 hours, so please cap the lifetime accordingly\".\r\n\r\n> Do we need a timestamp or can we use batches are granularity?\r\n\r\nIsn't batches granularity just not landing this PR? I think the subscriber will need a timestamp at least, because the subscriber doesn't know the CA's parameters. Of course, if it's _just_ for the subscriber, we could put it in CertificatePropertyList and leave the certificate format alone.\r\n\r\n> Maybe also good to ponder revocation again. Depending on how we solve that, we might achieve what we want, by issuing and then immediately revoking for a set time.\r\n\r\nWell revocation only works in clients that have picked up the revocation instruction. In applications like the web, that's not perfectly reliable. Hence short-lived certificates and everything else. I don't think revocation removes the need for both subscriber and CA to contribute upper bounds on the lifetime.\r\n\r\nOn that note, the PR should probably include a sentence to allow CAs to shorten the lifetime beyond the batch too.",
          "createdAt": "2024-09-23T13:43:07Z",
          "updatedAt": "2024-09-23T13:43:07Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "There is an issue: if you don't store not_after in the abridgedassertion, then the trust service can't compute HashAssertion and thus verify the tree.",
          "createdAt": "2024-09-23T14:21:34Z",
          "updatedAt": "2024-09-23T14:21:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Ah nice catch! I forgot about the HTTP interface.\r\n\r\nAbridgedAssertionAndTimestamp is a mouthful. It is annoying that probably every proof type will need a family of \"[abridged] assertion and not after\" structures and we don't good a word for that. Should it actually go in the assertion?? Trouble is this makes it harder to staple multiple proofs a la #88 if the proofs happen not to be clocked similarly, or have other lifetime constraints, and I kinda like the freedom to build PKIs out of that.",
          "createdAt": "2024-09-23T14:39:40Z",
          "updatedAt": "2024-09-23T14:39:40Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Alright, rebased and then reworked a bunch. This probably warrants a fresh review and possibly looking at individual commits for clarity.\r\n\r\nI rebased the PR.\r\n\r\nI addressed @lukevalenta's comment by being less prescriptive about where you get the expiration time.\r\n\r\nI addressed @bwesterb's comment by putting not_after into AbridgedAssertion.\r\n\r\nIn doing that, I realized calling this an abridged assertion gets... kinda weird, so I did a bigger change in hopes of resolving this. I tried calling them \"batch entries\" which seems to work? This resolves a few issues:\r\n* Abridged assertions contain more information than just the assertion (maybe not_after should just be in the assertion??? https://github.com/davidben/merkle-tree-certs/pull/92#issuecomment-2362330928 was the rationale for sticking them with the proof)\r\n* Abridged assertions are currently presented as a funny implementation detail of leaf hashing, but they're more than that. They're also the thing we serve in the HTTP list.\r\n\r\nSo the phrasing around \"batch entries\" tries to talk about them as being *the* contents of the Merkle Tree.\r\n\r\nFinally, I noticed a weird inconsistency in how we refer to hash values so cleaned that up.\r\n\r\nThoughts?",
          "createdAt": "2025-03-06T20:07:58Z",
          "updatedAt": "2025-03-06T20:08:08Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> So the phrasing around \"batch entries\" tries to talk about them as being _the_ contents of the Merkle Tree.\r\n\r\nWhat about *commitments*? Or is that too crypto-y?",
          "createdAt": "2025-03-06T20:16:53Z",
          "updatedAt": "2025-03-06T20:16:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> One implementation consideration (which doesn't need to be part of the spec): right now the [Key()](https://github.com/bwesterb/mtc/blob/main/mtc.go#L1285) function computes a key for an abridged assertion, which is used in various indices and by authenticating parties to request a BikeshedCertificate for a given issued assertion. I think we'll want to omit the NotAfter field from that key as it's mutable. Instead, the key should be derived from fields in the Assertion structure itself.\r\n\r\nAh yeah, another reason to have not_after be part of the Proof rather than the Assertion I guess.",
          "createdAt": "2025-03-13T02:41:45Z",
          "updatedAt": "2025-03-13T02:41:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> What about commitments? Or is that too crypto-y?\r\n\r\nI feel like \"entry\" feels more understandable than \"commitment\" to me, but I'm perhaps not up on the relevant lingo here. I was just thinking \"this is what is actually in the log\", because the log does not (necessarily) log the unhashed keys.\r\n\r\n*shrug* We can always reshuffle this later.",
          "createdAt": "2025-03-13T02:42:59Z",
          "updatedAt": "2025-03-13T02:42:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc6efAgc",
          "commit": {
            "abbreviatedOid": "5d26558"
          },
          "author": "lukevalenta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-04T20:37:15Z",
          "updatedAt": "2025-03-04T20:42:52Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "In our current implementation (which of course we're happy to change), subscribers submit an `AssertionRequest` to the CA which contains the assertion, evidence, and requested maximum `not_after`. But before queuing that `AssertionRequest`, the CA computes the effective `not_after` as the minimum of the subscriber-requested `not_after`, the next-to-be-issued-batch's expiration time, and any constraints for the evidence (e.g., X.509 cert or revocation check expiry).\r\n\r\nThe reason we compute the effective `not_after` date at queue time is that otherwise we'd have to re-validate all of the evidence at issuance time, which could be a bottleneck and doesn't allow us to return a clear error to the subscriber about why the assertion request was rejected. It also means that we use the next-to-be-issued batch's expiration time instead of the actual batch's expiration time, which prevents assertions from having a longer-than-expected lifetime if there are issuance delays (related to #105).",
              "createdAt": "2025-03-04T20:37:15Z",
              "updatedAt": "2025-03-04T20:43:51Z"
            },
            {
              "originalPosition": 5,
              "body": "Regarding evidence (#23), that's also going into the queue in our implementation as part of the `AssertionRequest`, but should be fine to leave that out of this PR.",
              "createdAt": "2025-03-04T20:40:02Z",
              "updatedAt": "2025-03-04T20:42:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6esa22",
          "commit": {
            "abbreviatedOid": "5d26558"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-05T20:43:54Z",
          "updatedAt": "2025-03-05T20:43:54Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Ah hmm. I mean, both behaviors seem perfectly legitimate to me, so ideally the text would admit both. I guess what you're doing could be modeled as computing a different requested expiration time _before_ entering the queue, which happens to be always less than `batch_not_after`. But that is definitely on the confusing side. Will wordsmith a bit.",
              "createdAt": "2025-03-05T20:43:54Z",
              "updatedAt": "2025-03-05T20:43:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6e4cZs",
          "commit": {
            "abbreviatedOid": "9f2a984"
          },
          "author": "lukevalenta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Modulo a missing period and whether to call the leaves 'commitments' or 'entries' (I think either is fine, although 'entries' is more succinct), looks good to me!\r\n\r\nOne implementation consideration (which doesn't need to be part of the spec): right now the [Key()](https://github.com/bwesterb/mtc/blob/main/mtc.go#L1285) function computes a key for an abridged assertion, which is used in various indices and by authenticating parties to request a BikeshedCertificate for a given issued assertion. I think we'll want to omit the `NotAfter` field from that key as it's mutable. Instead, the key should be derived from fields in the Assertion structure itself.\r\n\r\n",
          "createdAt": "2025-03-06T20:50:33Z",
          "updatedAt": "2025-03-07T14:34:15Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "typo: missing period\r\n```suggestion\r\nA MerkleTreeEntry describes an Assertion ({{assertions}}) that has been certified up to expiration time. The `subject_info_hash` field is the hash of the `subject_info` field of the assertion. `not_after` is the expiration time as a POSIX timestamp (see {{time}}). The remaining fields match the Assertion structure.\r\n```",
              "createdAt": "2025-03-06T20:50:33Z",
              "updatedAt": "2025-03-07T14:33:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6fMJpL",
          "commit": {
            "abbreviatedOid": "9f2a984"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-10T12:21:51Z",
          "updatedAt": "2025-03-10T12:21:52Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Not ideal to have *batch entry*, *merkle tree entry* and *merkle tree leaf*. We should make this `BatchEntry` or use *Merkle tree entry* everywhere.",
              "createdAt": "2025-03-10T12:21:51Z",
              "updatedAt": "2025-03-10T12:39:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6fMWSo",
          "commit": {
            "abbreviatedOid": "9f2a984"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Don't think naming is ideal yet, but let's just move forward.",
          "createdAt": "2025-03-10T12:40:36Z",
          "updatedAt": "2025-03-10T12:40:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJIBkVc6fwleI",
          "commit": {
            "abbreviatedOid": "9f2a984"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-13T02:41:09Z",
          "updatedAt": "2025-03-13T02:41:09Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Ah yeah, done.",
              "createdAt": "2025-03-13T02:41:09Z",
              "updatedAt": "2025-03-13T02:41:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 94,
      "id": "PR_kwDOJIBkVc59gwDy",
      "title": "Switch \"subscriber\" to \"authenticating party\"",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/94",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [
        "bwesterb",
        "devonobrien"
      ],
      "labels": [],
      "body": "Closes #93. I left some instances in \"Size Estimates\" as subscriber because I think subscriber actually makes more sense in that case. (We're talking about a CA's active subscriber count.)",
      "createdAt": "2024-10-03T14:44:53Z",
      "updatedAt": "2024-10-03T15:52:13Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "ce779c60c77cce4d2d0679d268ba979af6fa41ae",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "auth-party",
      "headRefOid": "4fc56e06584346a88670c2bd0698b2f658ea0782",
      "closedAt": "2024-10-03T15:52:09Z",
      "mergedAt": "2024-10-03T15:52:09Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "0fe3626b2fd45f5f15fdb2a1ac56f9c23143125b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc6L06Bu",
          "commit": {
            "abbreviatedOid": "4fc56e0"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-03T15:05:50Z",
          "updatedAt": "2024-10-03T15:05:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 95,
      "id": "PR_kwDOJIBkVc5-iYLN",
      "title": "Use `<1..2^24-1>` encoding for all certificate types",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/95",
      "state": "MERGED",
      "author": "pohlm01",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In favor of an easier implementation, I propose to change the `CertificateEntry` TLS message such that the Bikeshed certificate is embedded in a length prefixed array. It makes parsing the packets sent over the wire agnostic to the negotiated certificate type. The interpretation/parsing can thus be postponed to checking the certificate.\r\nAs the side effect, it is halfway to the solution for negotiating client certificate types as discussed in [Section B.1](https://datatracker.ietf.org/doc/html/draft-davidben-tls-merkle-tree-certs-03#appendix-B.1).",
      "createdAt": "2024-10-14T12:29:21Z",
      "updatedAt": "2024-10-18T18:09:25Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "0fe3626b2fd45f5f15fdb2a1ac56f9c23143125b",
      "headRepository": "pohlm01/merkle-tree-certs",
      "headRefName": "main",
      "headRefOid": "ef4ba6a818d86b3531d5251a1712444597b00a02",
      "closedAt": "2024-10-18T18:09:25Z",
      "mergedAt": "2024-10-18T18:09:25Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "236102a050d47462060cbe2351c696df4a9506f2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc6NyCB3",
          "commit": {
            "abbreviatedOid": "ef4ba6a"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-18T18:09:17Z",
          "updatedAt": "2024-10-18T18:09:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 98,
      "id": "PR_kwDOJIBkVc6FFR0r",
      "title": "Update Dilithium reference to ML-DSA",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/98",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-12-13T00:00:59Z",
      "updatedAt": "2024-12-13T00:33:16Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "f74e52f630d33dcdc495de56e18af2869adbfbdb",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "mldsa",
      "headRefOid": "edf8c0fca993ae93dc7fc18c8944dfe3a2238f33",
      "closedAt": "2024-12-13T00:33:14Z",
      "mergedAt": "2024-12-13T00:33:14Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "f44aefce79d9b684e771cc0624e529aa7ee2e468"
      },
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Sizes of signatures are slightly different now.\r\n\r\n<img width=\"530\" alt=\"Screenshot 2024-12-13 at 01 05 04\" src=\"https://github.com/user-attachments/assets/84710eae-f0e1-4b14-98bc-3f2ff93f93ae\" />\r\n",
          "createdAt": "2024-12-13T00:05:23Z",
          "updatedAt": "2024-12-13T00:05:39Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "\ud83d\ude22 \r\n\r\nFixed.",
          "createdAt": "2024-12-13T00:24:56Z",
          "updatedAt": "2024-12-13T00:24:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc6VEkq4",
          "commit": {
            "abbreviatedOid": "bbfa111"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-13T00:03:40Z",
          "updatedAt": "2024-12-13T00:03:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 100,
      "id": "PR_kwDOJIBkVc6IEGav",
      "title": "Clarify in the overview that the steps happen at different timelines",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/100",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "There seems to be a routine confusion in thinking that RP <-> TS communication happens during each TLS connection. This has never been the case.",
      "createdAt": "2025-01-16T21:17:00Z",
      "updatedAt": "2025-01-17T04:24:16Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "f44aefce79d9b684e771cc0624e529aa7ee2e468",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "overview-three-stages",
      "headRefOid": "f12c0ebabe2984fc5f2957d38195043eb7aefc2f",
      "closedAt": "2025-01-17T04:24:12Z",
      "mergedAt": "2025-01-17T04:24:12Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "735bb2bfdd1eb5fe88092d4792f1b746465fbfa4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc6YcbfI",
          "commit": {
            "abbreviatedOid": "f12c0eb"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-16T23:05:17Z",
          "updatedAt": "2025-01-16T23:05:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 102,
      "id": "PR_kwDOJIBkVc6LKX2H",
      "title": "Rework discussion of the transparency ecosystem",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/102",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Although the transparency service was clearly described throughout the document as an abstraction and not actually necessarily one single centralized service, this seems to have been a point of confusion. The intent was to observe that this system actually allows the ecosystem to freely design trust models, mirroring roles, etc., all without impact to interoperability. As this all happens out of band, neither certificate issuance nor certificate usage is impacted by these choices, except that a certificate may or may not be selected by negotiation.\r\n\r\nThis seems to have been a confusing notion. To avoid that mess, recut these concepts in the document.\r\n\r\nFirst, define the role of a mirror as a concrete service with some responsibility. This picks up the mirroring aspects of the old example transparency services, but not the direct connection to an RP or trustworthiness. It's a freefloating service with some responsibility. You may or may not believe it meets those responsibilities.\r\n\r\nThen, define a relying party policy, for how an RP gets gets validity windows. This is more explicitly the source of implementation dependence. RPs can choose to trust some combination of mirrors when formulating this policy. We give several example policies, but don't mandate anything in particular.\r\n\r\nRewrite the rest of this text according to this framing.\r\n\r\nCloses #99.",
      "createdAt": "2025-02-13T21:13:40Z",
      "updatedAt": "2025-02-18T18:30:29Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "a5c49577810d4b7c05672201dc31a0352ca6a932",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "mirrors",
      "headRefOid": "60a486abf743e7e9f002edd5cae3bb058b5701b6",
      "closedAt": "2025-02-18T18:30:24Z",
      "mergedAt": "2025-02-18T18:30:24Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "de60f87670588158889968975c315fcbe1acf3d9"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Please feel free to go over this with a fine-toothed comb and nitpick. This probably does need a editing pass. (I'll try to do a review pass myself later in the day.)",
          "createdAt": "2025-02-13T21:14:14Z",
          "updatedAt": "2025-02-13T21:14:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc6b8T0e",
          "commit": {
            "abbreviatedOid": "0e87eaf"
          },
          "author": "lukevalenta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-13T21:37:55Z",
          "updatedAt": "2025-02-13T21:38:45Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I think we're missing the distinction between the RP and the RP's out-of-band update service here. This is important because of the privacy implications of a browser reaching out directly to mirrors, for example. Maybe we need separate boxes for those two entities to make things crystal clear?\r\n```suggestion\r\n5. The relying party's update service periodically fetches the latest validity window from mirrors that it trusts. This validity window will contain the new tree head.\r\n```",
              "createdAt": "2025-02-13T21:37:55Z",
              "updatedAt": "2025-02-13T21:38:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6b9jyB",
          "commit": {
            "abbreviatedOid": "0e87eaf"
          },
          "author": "lukevalenta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Left some suggestions, but overall the change looks good to me.",
          "createdAt": "2025-02-14T02:07:56Z",
          "updatedAt": "2025-02-14T14:24:21Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Or maybe just `signed`\r\n```suggestion\r\n: The relying party only accepts validity windows that were certified by the CA\r\n```",
              "createdAt": "2025-02-14T02:07:57Z",
              "updatedAt": "2025-02-14T14:24:22Z"
            },
            {
              "originalPosition": 264,
              "body": "An attempt to make this sentence a little more direct.\r\n```suggestion\r\nWhen a new service is provisioned with a brand new Merkle Tree certificate, relying parties cannot validate the certificate until they have received a validity window containing said certificate. The authenticating party SHOULD, in parallel, also provision a certificate using another PKI mechanism (e.g. X.509). Certificate negotiation will then switch over to serving the Merkle Tree certificate as relying parties are updated.\r\n```",
              "createdAt": "2025-02-14T02:21:25Z",
              "updatedAt": "2025-02-14T14:24:22Z"
            },
            {
              "originalPosition": 305,
              "body": "```suggestion\r\nThe mechanisms described in {{transparency-ecosystem}} do not prevent unauthorized certificates, but they aim to provide comparable security properties to Certificate Transparency {{?RFC6962}}. Before the relying party accepts a Merkle Tree Certificate, the relying party should have assurance the certificate was published in some form that monitors and, in particular, the subject of the certificate will be able to notice.\r\n```",
              "createdAt": "2025-02-14T13:09:16Z",
              "updatedAt": "2025-02-14T14:24:22Z"
            },
            {
              "originalPosition": 264,
              "body": "or perhaps just replace `receiving them` with `receiving such a window`",
              "createdAt": "2025-02-14T13:36:27Z",
              "updatedAt": "2025-02-14T14:24:22Z"
            },
            {
              "originalPosition": 331,
              "body": "```suggestion\r\nA CA could violate the append-only property of its batch state, and present differing views to different parties. Unlike a misbehaving Certificate Transparency log, this would not compromise transparency. Whichever view is presented to the relying party's trusted mirrors at the time of updates determines the canonical batch state for both relying parties and monitors. Certificates that are inconsistent with that view will be rejected by relying parties. If a mirror observes multiple views, the procedure in {{updating-a-mirror}} will prevent conflicting views from overwriting the originally saved view. Instead, the update process will fail and further certificates will not be accepted.\r\n```",
              "createdAt": "2025-02-14T13:43:30Z",
              "updatedAt": "2025-02-14T14:24:22Z"
            },
            {
              "originalPosition": 23,
              "body": "Not sure this is the best phrasing, but this is meant as an alternative to the suggestion at https://github.com/davidben/merkle-tree-certs/pull/102/files#r1955248648, to make sure a first-time reader of this document has the right mental model of how a RP is composed and to nip privacy concerns of browsers directly contacting mirrors in the bud. Otherwise, the reader has to wait until https://github.com/davidben/merkle-tree-certs/pull/102/files#diff-8ad89f700140e1da4a6c2c15605f9c168e6f85be9b64c9de2d2b1654be49ea8eR818.\r\n```suggestion\r\n: The party whom the authenticating party presents its identity to. In TLS, this is the side receiving the Certificate and CertificateVerify message. The relying party itself can consist of multiple components, such as a centralized update service that periodically updates software on end-user devices.\r\n```",
              "createdAt": "2025-02-14T13:59:47Z",
              "updatedAt": "2025-02-14T14:24:22Z"
            },
            {
              "originalPosition": 185,
              "body": "Just noting that if we go this route, it would be nice to leverage the co-signing mechanism of [tlog-witness](https://github.com/C2SP/C2SP/blob/main/tlog-witness.md).",
              "createdAt": "2025-02-14T14:05:41Z",
              "updatedAt": "2025-02-14T14:24:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6cGD5n",
          "commit": {
            "abbreviatedOid": "f0469ed"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-14T21:25:53Z",
          "updatedAt": "2025-02-14T23:57:24Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Oh good call. Hmm. I was hoping to be not very specific in most places and punt it all to the policy section. (Current takeaway is that scattering specific text leads without the big loud \"this is just an example!!\" is easy to misread.) But this is definitely accidentally specific in the other direction.\r\n\r\nRephrased but went more in the vague direction, WDYT?",
              "createdAt": "2025-02-14T21:25:53Z",
              "updatedAt": "2025-02-14T23:57:24Z"
            },
            {
              "originalPosition": 23,
              "body": "Not sure. Rather than be too prescriptive about the structure of the RP, I tried making the text outside policy bits more general, and then reworded the policy bits a bit.\r\n\r\nStill not sure if it's quite right, but maybe an okay direction. I'm sure we'll keep refining this more (and figuring out what to specify and what not) later, so I was mostly aiming here to contain the fluid part to the Transparency Ecosystem section.\r\n\r\nWDYT?",
              "createdAt": "2025-02-14T23:56:09Z",
              "updatedAt": "2025-02-14T23:57:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6cNuEu",
          "commit": {
            "abbreviatedOid": "f0469ed"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-17T11:52:42Z",
          "updatedAt": "2025-02-17T11:52:42Z",
          "comments": [
            {
              "originalPosition": 175,
              "body": "I like *misbehaving or compromised*. Transparency isn't just about keeping CAs honest, but also giving a well-behaving CA some assurance they've not been compromised.",
              "createdAt": "2025-02-17T11:52:42Z",
              "updatedAt": "2025-02-17T11:52:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6cNuge",
          "commit": {
            "abbreviatedOid": "f0469ed"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-17T11:53:31Z",
          "updatedAt": "2025-02-17T11:53:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJIBkVc6cYq3j",
          "commit": {
            "abbreviatedOid": "f0469ed"
          },
          "author": "lukevalenta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-18T14:13:36Z",
          "updatedAt": "2025-02-18T14:26:49Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Yeah, I like the approach you took here \ud83d\udc4d ",
              "createdAt": "2025-02-18T14:13:36Z",
              "updatedAt": "2025-02-18T14:26:49Z"
            },
            {
              "originalPosition": 45,
              "body": "The change to de-emphasize the RP directly contacting the mirror looks good!",
              "createdAt": "2025-02-18T14:14:20Z",
              "updatedAt": "2025-02-18T14:26:49Z"
            },
            {
              "originalPosition": 184,
              "body": "nit: if the two mirrors both serve the highest batch number then we don't want the second-highest\r\n```suggestion\r\n2. Compute the highest batch number that satisfies the policy. For example, if requiring windows be represented in at least two mirrors, use the second-to-last batch number after sorting in ascending order.\r\n```",
              "createdAt": "2025-02-18T14:26:43Z",
              "updatedAt": "2025-02-18T14:26:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6cb3dT",
          "commit": {
            "abbreviatedOid": "f0469ed"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-18T18:29:42Z",
          "updatedAt": "2025-02-18T18:29:42Z",
          "comments": [
            {
              "originalPosition": 175,
              "body": "Fair enough. I guess I would say that the CA is the service with a private key and the _CA operator_ is the entity that maintains it. If the CA is compromised, the _CA operator_ may well be honest, but the service is still misbehaving. But people are often sloppy enough about this that adding the extra word SGTM.\r\n\r\n```suggestion\r\nRelying parties SHOULD ensure transparency by obtaining validity windows from the CA and/or some combination of trusted mirrors. The relying party picks sources which, together, are trusted to satisfy the requirements described in {{mirrors}}. Mirrors allow the relying party to maintain transparency in the face of a misbehaving or compromised CA that may, for example, stop serving some unauthorized certificate in a batch to evade detection.\r\n```",
              "createdAt": "2025-02-18T18:29:42Z",
              "updatedAt": "2025-02-18T18:29:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 108,
      "id": "PR_kwDOJIBkVc6Ob1_C",
      "title": "Fix mirroring procedure issues in #107",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/108",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #107",
      "createdAt": "2025-03-13T02:50:52Z",
      "updatedAt": "2025-03-13T09:57:49Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "fc013fb7e878f849e6163b3f1e703ebafadfd264",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "fix-107",
      "headRefOid": "9a9a9a8e6a9b6dc6f1afb7ea7c9820d481c37f1d",
      "closedAt": "2025-03-13T09:57:46Z",
      "mergedAt": "2025-03-13T09:57:46Z",
      "mergedBy": "bwesterb",
      "mergeCommit": {
        "oid": "05d47379ac539ba3284198e79b843819b66b3388"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc6fwr1k",
          "commit": {
            "abbreviatedOid": "9a9a9a8"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-13T02:52:36Z",
          "updatedAt": "2025-03-13T02:52:36Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I noticed that this procedure is written as if you construct the ValidityWindow you expect rather than fetching it. I kept that but depending on how the HTTP format shakes out, maybe that'll change.\r\n\r\n(Also I'm getting convinced that maybe we should just chain the hashes together. It makes describing signatures more straightforward because you don't need to sign over the whole window, just the last hash. Though we still need to talk about validity windows because clients need to receive the whole list of hashes.)",
              "createdAt": "2025-03-13T02:52:36Z",
              "updatedAt": "2025-03-13T02:52:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc6f0HuW",
          "commit": {
            "abbreviatedOid": "9a9a9a8"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-13T09:57:26Z",
          "updatedAt": "2025-03-13T09:57:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 110,
      "id": "PR_kwDOJIBkVc6OjQwe",
      "title": "Downgrade hash agility to a NOTE",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/110",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft suggests hash functions other than SHA-256 might be used for the Merkle tree, but doesn't specify how. I think the intention is to signal to the reader that there's room for adding this agility in the future, so say so in an author note.",
      "createdAt": "2025-03-13T17:11:31Z",
      "updatedAt": "2025-03-18T02:24:43Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "05d47379ac539ba3284198e79b843819b66b3388",
      "headRepository": "cjpatton/merkle-tree-certs",
      "headRefName": "edit-1-unfunded-agility",
      "headRefOid": "4b78eb9a37668791c9fcb628c8463622f57a15b0",
      "closedAt": "2025-03-18T02:24:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Oh this is slightly interesting. Arguably, by what's in the draft right now, we actually have all the hash agility mechanisms we need. The hash is one of the parameters of the CA. If the relying party knows the CA, it's assumed to know all the CA parameters, which includes the the hash. So based on what's in the document _right now_, the only way we assume SHA-256 is just we vaguely hint that people should do that.\r\n\r\nBut this is kind of cheating because we said how to represent a trust anchor for relying parties. Once we do that, we'll need to start baking in the hash or adding an enum field with only one defined integer, or whatever. So... I think probably the thing to do is to get that done and then write whatever makes sense based on what we do there.",
          "createdAt": "2025-03-15T05:45:01Z",
          "updatedAt": "2025-03-15T05:45:01Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "SGTM. Another thing we might need to worry about is the output size of the hash, which is hard-coded to 32 in a lot of places. I don't think this will matter much in practice though, so we could explicitly restrict the set of hash functions with which MTCs are compatible.",
          "createdAt": "2025-03-17T14:19:20Z",
          "updatedAt": "2025-03-17T14:19:20Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Hmm that *should* all be parameterized now, unless I'm missing something. The idea was that the structures would all be specific to your hash because you would never usefully parse, say, an inclusion proof without prior knowledge of the CA parameters and thus hash size.",
          "createdAt": "2025-03-17T16:17:04Z",
          "updatedAt": "2025-03-17T16:17:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The only thing that stuck out to me was: \r\n```\r\n    uint8 label[32] = \"Merkle Tree Crts ValidityWindow\\0\";\r\n```\r\nI'm not sure if you picked 32 because you wanted this to match the ouptput size of SHA256. But I don't think it really matters :)",
          "createdAt": "2025-03-17T17:22:35Z",
          "updatedAt": "2025-03-17T17:22:35Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Oh hah! I think that was just a coincidence. :-D",
          "createdAt": "2025-03-18T00:05:30Z",
          "updatedAt": "2025-03-18T00:05:30Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 111,
      "id": "PR_kwDOJIBkVc6OvV1x",
      "title": "Add a missing \".\"",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/111",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-14T23:17:52Z",
      "updatedAt": "2025-03-15T05:20:26Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "05d47379ac539ba3284198e79b843819b66b3388",
      "headRepository": "cjpatton/merkle-tree-certs",
      "headRefName": "edit-2",
      "headRefOid": "79869bfec5b85bab831d13943234e8c37ebcb201",
      "closedAt": "2025-03-15T05:20:26Z",
      "mergedAt": "2025-03-15T05:20:26Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "e5b778aaa2d704afb5e9e821a04ec8172bea5182"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc6gLg9e",
          "commit": {
            "abbreviatedOid": "79869bf"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-15T05:20:10Z",
          "updatedAt": "2025-03-15T05:20:10Z",
          "comments": []
        }
      ]
    }
  ]
}